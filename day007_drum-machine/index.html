<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ドラムマシン | tiny-tools Day 7</title>
  <style>
    /* ══════════════════════════════════════════════
       1. RESET & BASE (DARK-FIRST)
       ══════════════════════════════════════════════ */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    body:not(.tt-dark) {
      background: #f0f0f5;
      color: #333;
    }

    /* ══════════════════════════════════════════════
       2. APP CONTAINER
       ══════════════════════════════════════════════ */
    .app {
      width: 100%;
      max-width: 960px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    /* ══════════════════════════════════════════════
       3. PANELS (shared)
       ══════════════════════════════════════════════ */
    .panel {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 10px;
      padding: 0.75rem 1rem;
    }
    body:not(.tt-dark) .panel {
      background: #fff;
      border-color: #ddd;
    }
    .panel-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #888;
      margin-bottom: 0.5rem;
    }

    /* ══════════════════════════════════════════════
       4. TRANSPORT
       ══════════════════════════════════════════════ */
    .transport {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .transport-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .btn {
      background: #0f3460;
      border: 1px solid #1a4a8a;
      color: #e0e0e0;
      border-radius: 6px;
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      font-family: inherit;
      white-space: nowrap;
    }
    .btn:hover { background: #1a4a8a; }
    .btn:active { transform: scale(0.97); }
    .btn.active { background: #e94560; border-color: #e94560; color: #fff; }
    body:not(.tt-dark) .btn {
      background: #e8ecf2;
      border-color: #ccd;
      color: #333;
    }
    body:not(.tt-dark) .btn:hover { background: #d0d8e8; }
    body:not(.tt-dark) .btn.active { background: #e94560; border-color: #e94560; color: #fff; }

    .btn-play {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .btn-play.playing { background: #e94560; border-color: #e94560; }

    .transport label {
      font-size: 0.75rem;
      color: #888;
    }
    .transport input[type="range"] {
      width: 80px;
      accent-color: #e94560;
    }
    .bpm-input {
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-radius: 6px;
      color: #e94560;
      font-size: 1.4rem;
      font-weight: 700;
      font-family: inherit;
      font-variant-numeric: tabular-nums;
      width: 4.5ch;
      text-align: center;
      padding: 0.2rem 0.3rem;
      -moz-appearance: textfield;
    }
    .bpm-input::-webkit-outer-spin-button,
    .bpm-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .bpm-input:focus {
      outline: none;
      border-color: #e94560;
    }
    body:not(.tt-dark) .bpm-input {
      background: #f5f5f8;
      border-color: #ccd;
      color: #c0354a;
    }
    body:not(.tt-dark) .bpm-input:focus {
      border-color: #c0354a;
    }
    .swing-value {
      font-size: 0.75rem;
      color: #aaa;
      min-width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* ══════════════════════════════════════════════
       5. PATTERN BAR
       ══════════════════════════════════════════════ */
    .pattern-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .pattern-btns {
      display: flex;
      gap: 0.3rem;
    }
    .pattern-btn {
      width: 36px;
      height: 32px;
      font-size: 0.85rem;
      font-weight: 700;
    }
    .pattern-btn.active {
      background: #e94560;
      border-color: #e94560;
      color: #fff;
    }
    .chain-input {
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-radius: 6px;
      color: #e0e0e0;
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      width: 120px;
      font-family: inherit;
    }
    body:not(.tt-dark) .chain-input {
      background: #f5f5f8;
      border-color: #ccd;
      color: #333;
    }
    .chain-input::placeholder { color: #666; }

    /* ══════════════════════════════════════════════
       6. SEQUENCER GRID
       ══════════════════════════════════════════════ */
    .sequencer {
      overflow-x: auto;
    }
    .track-row {
      display: flex;
      align-items: center;
      gap: 0;
      margin-bottom: 2px;
    }
    .track-label {
      width: 72px;
      flex-shrink: 0;
      font-size: 0.72rem;
      font-weight: 600;
      padding: 0 6px;
      text-align: right;
      cursor: pointer;
      user-select: none;
      opacity: 0.9;
      line-height: 1.2;
    }
    .track-label:hover { opacity: 1; }
    .steps {
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      gap: 3px;
      flex: 1;
      min-width: 0;
    }
    .step {
      aspect-ratio: 1;
      min-width: 0;
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.08s, border-color 0.08s, transform 0.08s;
      position: relative;
    }
    .step:hover { border-color: #555; transform: scale(1.05); }
    .step.on { border-color: transparent; }
    .step.current {
      box-shadow: 0 0 0 2px #e94560, 0 0 8px rgba(233, 69, 96, 0.4);
    }
    body:not(.tt-dark) .step {
      border-color: #ccc;
    }
    body:not(.tt-dark) .step.current {
      box-shadow: 0 0 0 2px #e94560, 0 0 8px rgba(233, 69, 96, 0.3);
    }

    /* 4-step grouping */
    .step:nth-child(4n+1) { margin-left: 4px; }
    .step:nth-child(1) { margin-left: 0; }

    /* Step OFF colors (dark beats) */
    .step.beat { background: #252545; }
    .step.offbeat { background: #1e1e38; }
    body:not(.tt-dark) .step.beat { background: #e8e8f0; }
    body:not(.tt-dark) .step.offbeat { background: #f0f0f5; }

    /* Track controls */
    .track-ctrls {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: 8px;
      flex-shrink: 0;
    }
    .track-ctrls input[type="range"] {
      width: 50px;
      accent-color: #e94560;
      height: 14px;
    }
    .ctrl-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #4a4a6a;
      color: #aaa;
      border-radius: 4px;
      width: 22px;
      height: 22px;
      font-size: 0.6rem;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.1s, color 0.1s;
      font-family: inherit;
      padding: 0;
    }
    .ctrl-btn:hover { border-color: #6a6a8a; color: #ddd; }
    .ctrl-btn.muted { background: #e94560; border-color: #e94560; color: #fff; }
    .ctrl-btn.soloed { background: #f0a500; border-color: #f0a500; color: #1a1a2e; }
    body:not(.tt-dark) .ctrl-btn { border-color: #ccc; color: #888; }
    body:not(.tt-dark) .ctrl-btn.muted { background: #e94560; border-color: #e94560; color: #fff; }
    body:not(.tt-dark) .ctrl-btn.soloed { background: #f0a500; border-color: #f0a500; color: #222; }

    /* ══════════════════════════════════════════════
       7. VISUALIZER
       ══════════════════════════════════════════════ */
    .visualizer-section canvas {
      width: 100%;
      height: 64px;
      border-radius: 6px;
      display: block;
      background: #0d0d1a;
    }
    body:not(.tt-dark) .visualizer-section canvas {
      background: #e0e0ea;
    }

    /* ══════════════════════════════════════════════
       8. FOOTER BAR
       ══════════════════════════════════════════════ */
    .footer-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .footer-bar .btn { font-size: 0.78rem; padding: 0.35rem 0.6rem; }

    /* ══════════════════════════════════════════════
       9. TOAST
       ══════════════════════════════════════════════ */
    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #333;
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.85rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s, transform 0.25s;
      z-index: 2000;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    /* ══════════════════════════════════════════════
       10. SHORTCUTS HELP
       ══════════════════════════════════════════════ */
    .shortcuts-help {
      font-size: 0.7rem;
      color: #666;
      text-align: center;
      padding: 0.3rem 0;
    }
    .shortcuts-help kbd {
      background: #252545;
      border: 1px solid #3a3a5a;
      border-radius: 3px;
      padding: 1px 5px;
      font-family: inherit;
      font-size: 0.68rem;
    }
    body:not(.tt-dark) .shortcuts-help kbd {
      background: #e8e8f0;
      border-color: #ccc;
    }

    /* ══════════════════════════════════════════════
       11. RESPONSIVE
       ══════════════════════════════════════════════ */
    @media (max-width: 640px) {
      .app { padding: 0.5rem; }
      .track-label { width: 56px; font-size: 0.65rem; }
      .track-ctrls input[type="range"] { width: 36px; }
      .steps { gap: 2px; }
      .step:nth-child(4n+1) { margin-left: 2px; }
      .transport input[type="range"] { width: 60px; }
    }
  </style>
  <script src="../shared/header.js" data-repo="https://github.com/sanasuke/tiny-tools" data-note="https://note.com/sana_suke"></script>
</head>
<body class="tt-dark">
  <div class="app">
    <!-- Transport -->
    <div class="panel transport" id="transport">
      <button class="btn btn-play" id="playBtn" title="再生/停止 (Space)">&#9654;</button>
      <div class="transport-group">
        <label>BPM</label>
        <button class="btn" id="bpmDown" title="BPM -5 (-)">-</button>
        <input type="number" class="bpm-input" id="bpmInput" min="60" max="200" value="120" title="BPM">
        <button class="btn" id="bpmUp" title="BPM +5 (+)">+</button>
      </div>
      <div class="transport-group">
        <label>Swing</label>
        <input type="range" id="swingSlider" min="0" max="100" value="0" title="スイング">
        <span class="swing-value" id="swingValue">0%</span>
      </div>
    </div>

    <!-- Pattern Bar -->
    <div class="panel pattern-bar" id="patternBar">
      <span class="panel-title" style="margin-bottom:0">PATTERN</span>
      <div class="pattern-btns" id="patternBtns"></div>
      <button class="btn" id="copyBtn" title="パターンをコピー">Copy</button>
      <button class="btn" id="pasteBtn" title="パターンを貼り付け">Paste</button>
      <button class="btn" id="clearBtn" title="パターンをクリア">Clear</button>
      <div class="transport-group">
        <label>Chain</label>
        <input class="chain-input" id="chainInput" placeholder="例: AABB ABCD" title="パターンチェーン">
      </div>
    </div>

    <!-- Sequencer Grid -->
    <div class="panel sequencer" id="sequencer"></div>

    <!-- Visualizer -->
    <div class="panel visualizer-section">
      <canvas id="vizCanvas" height="64"></canvas>
    </div>

    <!-- Footer -->
    <div class="panel footer-bar">
      <button class="btn" id="exportWav">WAV出力</button>
      <button class="btn" id="saveBtn">保存</button>
      <button class="btn" id="loadBtn">読込</button>
      <button class="btn" id="shareBtn">リンク共有</button>
      <input type="file" id="loadFile" accept=".json" style="display:none">
    </div>

    <!-- Shortcuts -->
    <div class="shortcuts-help">
      <kbd>Space</kbd> 再生/停止 &nbsp;
      <kbd>1</kbd>-<kbd>4</kbd> パターン切替 &nbsp;
      <kbd>+</kbd>/<kbd>-</kbd> BPM &nbsp;
      <kbd>Ctrl+S</kbd> 保存 &nbsp;
      <kbd>Ctrl+E</kbd> WAV出力
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

<script>
(function () {
  'use strict';

  /* ══════════════════════════════════════════════
     1. CONSTANTS & TRACK DEFINITIONS
     ══════════════════════════════════════════════ */
  var NUM_STEPS = 16;
  var NUM_TRACKS = 8;
  var PATTERNS = ['A', 'B', 'C', 'D'];
  var LOOK_AHEAD = 0.1;   // seconds
  var SCHEDULE_INTERVAL = 25; // ms

  var TRACKS = [
    { name: 'Kick',     color: '#e94560', colorLight: '#c0354a' },
    { name: 'Snare',    color: '#e94560', colorLight: '#c0354a' },
    { name: 'HH Close', color: '#00d2d3', colorLight: '#008b8b' },
    { name: 'HH Open',  color: '#00d2d3', colorLight: '#008b8b' },
    { name: 'Clap',     color: '#f0a500', colorLight: '#c08400' },
    { name: 'Rim',      color: '#f0a500', colorLight: '#c08400' },
    { name: 'Tom',      color: '#9b59b6', colorLight: '#7d3c98' },
    { name: 'Cymbal',   color: '#9b59b6', colorLight: '#7d3c98' }
  ];

  /* ══════════════════════════════════════════════
     2. STATE
     ══════════════════════════════════════════════ */
  var state = {
    bpm: 120,
    swing: 0,           // 0-100
    activePattern: 0,   // index into patterns array
    patterns: [],       // [4] arrays of [8][16] booleans
    trackVolume: [],    // [8] 0.0 - 1.0
    trackPitch: [],     // [8] -12 to +12
    trackMute: [],      // [8] boolean
    trackSolo: [],      // [8] boolean
    isPlaying: false,
    currentStep: -1,
    clipboard: null     // copied pattern data
  };

  // Initialize patterns
  for (var p = 0; p < 4; p++) {
    var patternData = [];
    for (var t = 0; t < NUM_TRACKS; t++) {
      var row = [];
      for (var s = 0; s < NUM_STEPS; s++) row.push(false);
      patternData.push(row);
    }
    state.patterns.push(patternData);
  }

  // Initialize track controls
  for (var i = 0; i < NUM_TRACKS; i++) {
    state.trackVolume.push(0.8);
    state.trackPitch.push(0);
    state.trackMute.push(false);
    state.trackSolo.push(false);
  }

  function currentPattern() {
    return state.patterns[state.activePattern];
  }

  /* ══════════════════════════════════════════════
     3. AUDIO CONTEXT (lazy init)
     ══════════════════════════════════════════════ */
  var audioCtx = null;
  var masterGain = null;
  var analyser = null;
  var noiseBuffer = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.8;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    masterGain.connect(analyser);
    analyser.connect(audioCtx.destination);

    // Create shared noise buffer (2 seconds)
    var bufferSize = audioCtx.sampleRate * 2;
    noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    var data = noiseBuffer.getChannelData(0);
    for (var i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
  }

  function createNoiseSource(ctx, buffer) {
    var src = ctx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    return src;
  }

  /* ══════════════════════════════════════════════
     4. DRUM SYNTHESIS (8 sounds)
     ══════════════════════════════════════════════ */

  // Helper: pitch multiplier from semitones
  function pitchMul(semitones) {
    return Math.pow(2, semitones / 12);
  }

  // Kick: sine osc + pitch envelope (150→50Hz), 0.4s decay
  function synthKick(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150 * mul, time);
    osc.frequency.exponentialRampToValueAtTime(50 * mul, time + 0.08);
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
    osc.connect(gain);
    gain.connect(dest);
    osc.start(time);
    osc.stop(time + 0.4);
  }

  // Snare: triangle osc (200Hz) + noise + bandpass (3kHz), 0.15s
  function synthSnare(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    // Tone component
    var osc = ctx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = 200 * mul;
    var oscGain = ctx.createGain();
    oscGain.gain.setValueAtTime(vol * 0.7, time);
    oscGain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
    osc.connect(oscGain);
    oscGain.connect(dest);
    osc.start(time);
    osc.stop(time + 0.15);

    // Noise component
    var noise = createNoiseSource(ctx, noiseBuffer);
    var bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 3000 * mul;
    bp.Q.value = 1.0;
    var nGain = ctx.createGain();
    nGain.gain.setValueAtTime(vol * 0.6, time);
    nGain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
    noise.connect(bp);
    bp.connect(nGain);
    nGain.connect(dest);
    noise.start(time);
    noise.stop(time + 0.15);
  }

  // HH Close: noise + highpass (7kHz), 0.05s
  function synthHHClose(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var noise = createNoiseSource(ctx, noiseBuffer);
    var hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 7000 * mul;
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol * 0.4, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
    noise.connect(hp);
    hp.connect(gain);
    gain.connect(dest);
    noise.start(time);
    noise.stop(time + 0.05);
  }

  // HH Open: noise + highpass (6kHz), 0.3s
  function synthHHOpen(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var noise = createNoiseSource(ctx, noiseBuffer);
    var hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 6000 * mul;
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol * 0.4, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
    noise.connect(hp);
    hp.connect(gain);
    gain.connect(dest);
    noise.start(time);
    noise.stop(time + 0.3);
  }

  // Clap: noise bursts ×3 (5ms spacing) + bandpass (1.5kHz) + tail, 0.15s
  function synthClap(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1500 * mul;
    bp.Q.value = 0.8;
    bp.connect(dest);

    for (var i = 0; i < 3; i++) {
      var t = time + i * 0.005;
      var noise = createNoiseSource(ctx, noiseBuffer);
      var gain = ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(vol * 0.6, t + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
      noise.connect(gain);
      gain.connect(bp);
      noise.start(t);
      noise.stop(t + 0.02);
    }

    // Tail
    var tailNoise = createNoiseSource(ctx, noiseBuffer);
    var tailGain = ctx.createGain();
    tailGain.gain.setValueAtTime(vol * 0.35, time + 0.01);
    tailGain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
    tailNoise.connect(tailGain);
    tailGain.connect(bp);
    tailNoise.start(time + 0.01);
    tailNoise.stop(time + 0.15);
  }

  // Tom: sine osc + pitch envelope (200→80Hz), 0.3s
  function synthTom(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(200 * mul, time);
    osc.frequency.exponentialRampToValueAtTime(80 * mul, time + 0.15);
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol * 0.8, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
    osc.connect(gain);
    gain.connect(dest);
    osc.start(time);
    osc.stop(time + 0.3);
  }

  // Rim: triangle osc (800Hz) + noise click, 0.05s
  function synthRim(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var osc = ctx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = 800 * mul;
    var oscGain = ctx.createGain();
    oscGain.gain.setValueAtTime(vol * 0.6, time);
    oscGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
    osc.connect(oscGain);
    oscGain.connect(dest);
    osc.start(time);
    osc.stop(time + 0.05);

    var noise = createNoiseSource(ctx, noiseBuffer);
    var hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 4000 * mul;
    var nGain = ctx.createGain();
    nGain.gain.setValueAtTime(vol * 0.3, time);
    nGain.gain.exponentialRampToValueAtTime(0.001, time + 0.02);
    noise.connect(hp);
    hp.connect(nGain);
    nGain.connect(dest);
    noise.start(time);
    noise.stop(time + 0.05);
  }

  // Cymbal: multiple detuned square oscs (3-6kHz) + highpass, 0.8s
  function synthCymbal(ctx, dest, time, vol, pitch) {
    var mul = pitchMul(pitch);
    var hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 5000 * mul;
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol * 0.25, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.8);
    hp.connect(gain);
    gain.connect(dest);

    var freqs = [3200, 4100, 4800, 5800];
    freqs.forEach(function (f) {
      var osc = ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.value = f * mul;
      osc.connect(hp);
      osc.start(time);
      osc.stop(time + 0.8);
    });
  }

  var synthFunctions = [
    synthKick, synthSnare, synthHHClose, synthHHOpen,
    synthClap, synthRim, synthTom, synthCymbal
  ];

  // Generic play function - works with any AudioContext/destination
  function playSound(ctx, dest, nBuf, trackIndex, time, vol, pitch) {
    // Temporarily swap noiseBuffer for offline rendering
    var origNoise = noiseBuffer;
    noiseBuffer = nBuf;
    synthFunctions[trackIndex](ctx, dest, time, vol, pitch);
    noiseBuffer = origNoise;
  }

  /* ══════════════════════════════════════════════
     5. SCHEDULER (look-ahead)
     ══════════════════════════════════════════════ */
  var schedulerTimer = null;
  var nextStepTime = 0;
  var currentScheduleStep = 0;
  var chainQueue = [];
  var chainIndex = 0;

  function getStepDuration() {
    return 60.0 / state.bpm / 4; // 16th note
  }

  function getSwingOffset() {
    return getStepDuration() * (state.swing / 100) * 0.33;
  }

  function isTrackAudible(trackIdx) {
    if (state.trackMute[trackIdx]) return false;
    var anySolo = state.trackSolo.some(function (s) { return s; });
    if (anySolo && !state.trackSolo[trackIdx]) return false;
    return true;
  }

  function scheduleStep(stepIndex, time) {
    var pattern = currentPattern();
    for (var t = 0; t < NUM_TRACKS; t++) {
      if (pattern[t][stepIndex] && isTrackAudible(t)) {
        synthFunctions[t](audioCtx, masterGain, time, state.trackVolume[t], state.trackPitch[t]);
      }
    }
  }

  function advanceStep() {
    var swingOffset = (currentScheduleStep % 2 === 1) ? getSwingOffset() : 0;
    currentScheduleStep++;
    if (currentScheduleStep >= NUM_STEPS) {
      currentScheduleStep = 0;
      advanceChain();
    }
    nextStepTime += getStepDuration() + swingOffset;
  }

  function advanceChain() {
    if (chainQueue.length > 0) {
      chainIndex = (chainIndex + 1) % chainQueue.length;
      state.activePattern = chainQueue[chainIndex];
      updatePatternBtns();
    }
  }

  function schedulerLoop() {
    if (!audioCtx) return;
    while (nextStepTime < audioCtx.currentTime + LOOK_AHEAD) {
      scheduleStep(currentScheduleStep, nextStepTime);
      // Schedule UI update
      var step = currentScheduleStep;
      var drawTime = (nextStepTime - audioCtx.currentTime) * 1000;
      setTimeout(function (s) {
        return function () {
          state.currentStep = s;
          updateStepHighlight();
        };
      }(step), Math.max(0, drawTime));
      advanceStep();
    }
  }

  /* ══════════════════════════════════════════════
     6. TRANSPORT
     ══════════════════════════════════════════════ */
  function startPlayback() {
    ensureAudio();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    state.isPlaying = true;
    currentScheduleStep = 0;
    nextStepTime = audioCtx.currentTime + 0.05;

    // Parse chain
    parseChain();

    schedulerTimer = setInterval(schedulerLoop, SCHEDULE_INTERVAL);
    playBtn.classList.add('playing');
    playBtn.innerHTML = '&#9632;'; // stop symbol
  }

  function stopPlayback() {
    state.isPlaying = false;
    state.currentStep = -1;
    clearInterval(schedulerTimer);
    schedulerTimer = null;
    updateStepHighlight();
    playBtn.classList.remove('playing');
    playBtn.innerHTML = '&#9654;'; // play symbol
  }

  function togglePlayback() {
    if (state.isPlaying) stopPlayback(); else startPlayback();
  }

  function setBpm(val) {
    state.bpm = Math.max(60, Math.min(200, val));
    bpmInput.value = state.bpm;
  }

  /* ══════════════════════════════════════════════
     7. SEQUENCER GRID UI (dynamic DOM)
     ══════════════════════════════════════════════ */
  var stepElements = []; // [track][step] -> DOM element

  function buildGrid() {
    var container = document.getElementById('sequencer');
    container.innerHTML = '';
    stepElements = [];

    for (var t = 0; t < NUM_TRACKS; t++) {
      var row = document.createElement('div');
      row.className = 'track-row';

      // Label
      var label = document.createElement('div');
      label.className = 'track-label';
      label.textContent = TRACKS[t].name;
      label.style.color = TRACKS[t].color;
      label.dataset.track = t;
      row.appendChild(label);

      // Steps
      var stepsDiv = document.createElement('div');
      stepsDiv.className = 'steps';
      var trackSteps = [];

      for (var s = 0; s < NUM_STEPS; s++) {
        var step = document.createElement('div');
        step.className = 'step ' + (s % 8 < 4 ? 'beat' : 'offbeat');
        step.dataset.track = t;
        step.dataset.step = s;
        stepsDiv.appendChild(step);
        trackSteps.push(step);
      }
      stepElements.push(trackSteps);
      row.appendChild(stepsDiv);

      // Track controls
      var ctrls = document.createElement('div');
      ctrls.className = 'track-ctrls';

      // Volume slider
      var volSlider = document.createElement('input');
      volSlider.type = 'range';
      volSlider.min = '0';
      volSlider.max = '100';
      volSlider.value = String(state.trackVolume[t] * 100);
      volSlider.title = '音量';
      volSlider.dataset.track = t;
      volSlider.dataset.ctrl = 'vol';
      ctrls.appendChild(volSlider);

      // Mute button
      var muteBtn = document.createElement('button');
      muteBtn.className = 'ctrl-btn';
      muteBtn.textContent = 'M';
      muteBtn.title = 'ミュート';
      muteBtn.dataset.track = t;
      muteBtn.dataset.ctrl = 'mute';
      ctrls.appendChild(muteBtn);

      // Solo button
      var soloBtn = document.createElement('button');
      soloBtn.className = 'ctrl-btn';
      soloBtn.textContent = 'S';
      soloBtn.title = 'ソロ';
      soloBtn.dataset.track = t;
      soloBtn.dataset.ctrl = 'solo';
      ctrls.appendChild(soloBtn);

      row.appendChild(ctrls);
      container.appendChild(row);
    }

    updateGridUI();
  }

  function updateGridUI() {
    var pattern = currentPattern();
    for (var t = 0; t < NUM_TRACKS; t++) {
      for (var s = 0; s < NUM_STEPS; s++) {
        var el = stepElements[t][s];
        if (pattern[t][s]) {
          el.classList.add('on');
          el.style.background = TRACKS[t].color;
        } else {
          el.classList.remove('on');
          el.style.background = '';
        }
      }
    }
  }

  function updateStepHighlight() {
    for (var t = 0; t < NUM_TRACKS; t++) {
      for (var s = 0; s < NUM_STEPS; s++) {
        stepElements[t][s].classList.toggle('current', s === state.currentStep);
      }
    }
  }

  function updateTrackControls() {
    var container = document.getElementById('sequencer');
    var rows = container.querySelectorAll('.track-row');
    rows.forEach(function (row, t) {
      var ctrls = row.querySelectorAll('.ctrl-btn');
      ctrls.forEach(function (btn) {
        if (btn.dataset.ctrl === 'mute') {
          btn.classList.toggle('muted', state.trackMute[t]);
        } else if (btn.dataset.ctrl === 'solo') {
          btn.classList.toggle('soloed', state.trackSolo[t]);
        }
      });
    });
  }

  /* ══════════════════════════════════════════════
     8. EVENT DELEGATION (sequencer)
     ══════════════════════════════════════════════ */
  function handleSequencerClick(e) {
    var el = e.target;

    // Step click
    if (el.classList.contains('step')) {
      ensureAudio();
      var t = parseInt(el.dataset.track);
      var s = parseInt(el.dataset.step);
      var pattern = currentPattern();
      pattern[t][s] = !pattern[t][s];

      if (pattern[t][s]) {
        el.classList.add('on');
        el.style.background = TRACKS[t].color;
        // Preview sound
        synthFunctions[t](audioCtx, masterGain, audioCtx.currentTime, state.trackVolume[t], state.trackPitch[t]);
      } else {
        el.classList.remove('on');
        el.style.background = '';
      }
      return;
    }

    // Track label click -> preview sound
    if (el.classList.contains('track-label')) {
      ensureAudio();
      var trackIdx = parseInt(el.dataset.track);
      synthFunctions[trackIdx](audioCtx, masterGain, audioCtx.currentTime, state.trackVolume[trackIdx], state.trackPitch[trackIdx]);
      return;
    }

    // Mute/Solo buttons
    if (el.dataset.ctrl === 'mute') {
      var ti = parseInt(el.dataset.track);
      state.trackMute[ti] = !state.trackMute[ti];
      updateTrackControls();
      return;
    }
    if (el.dataset.ctrl === 'solo') {
      var ti2 = parseInt(el.dataset.track);
      state.trackSolo[ti2] = !state.trackSolo[ti2];
      updateTrackControls();
      return;
    }
  }

  function handleSequencerInput(e) {
    var el = e.target;
    if (el.dataset.ctrl === 'vol') {
      var t = parseInt(el.dataset.track);
      state.trackVolume[t] = parseInt(el.value) / 100;
    }
  }

  /* ══════════════════════════════════════════════
     9. PATTERN MANAGEMENT
     ══════════════════════════════════════════════ */
  function buildPatternBtns() {
    var container = document.getElementById('patternBtns');
    container.innerHTML = '';
    PATTERNS.forEach(function (name, i) {
      var btn = document.createElement('button');
      btn.className = 'btn pattern-btn' + (i === state.activePattern ? ' active' : '');
      btn.textContent = name;
      btn.title = 'パターン ' + name + ' (' + (i + 1) + ')';
      btn.dataset.pattern = i;
      container.appendChild(btn);
    });
  }

  function updatePatternBtns() {
    var btns = document.querySelectorAll('.pattern-btn');
    btns.forEach(function (btn) {
      btn.classList.toggle('active', parseInt(btn.dataset.pattern) === state.activePattern);
    });
  }

  function switchPattern(idx) {
    state.activePattern = idx;
    updatePatternBtns();
    updateGridUI();
  }

  function copyPattern() {
    state.clipboard = JSON.parse(JSON.stringify(currentPattern()));
    showToast('パターン ' + PATTERNS[state.activePattern] + ' をコピーしました');
  }

  function pastePattern() {
    if (!state.clipboard) {
      showToast('コピーされたパターンがありません');
      return;
    }
    state.patterns[state.activePattern] = JSON.parse(JSON.stringify(state.clipboard));
    updateGridUI();
    showToast('パターン ' + PATTERNS[state.activePattern] + ' に貼り付けました');
  }

  function clearPattern() {
    var pattern = currentPattern();
    for (var t = 0; t < NUM_TRACKS; t++) {
      for (var s = 0; s < NUM_STEPS; s++) {
        pattern[t][s] = false;
      }
    }
    updateGridUI();
    showToast('パターン ' + PATTERNS[state.activePattern] + ' をクリアしました');
  }

  function parseChain() {
    var raw = chainInput.value.replace(/\s/g, '').toUpperCase();
    if (!raw) {
      chainQueue = [];
      chainIndex = 0;
      return;
    }
    chainQueue = [];
    for (var i = 0; i < raw.length; i++) {
      var idx = PATTERNS.indexOf(raw[i]);
      if (idx >= 0) chainQueue.push(idx);
    }
    if (chainQueue.length > 0) {
      chainIndex = 0;
      state.activePattern = chainQueue[0];
      updatePatternBtns();
      updateGridUI();
    }
  }

  /* ══════════════════════════════════════════════
     10. VISUALIZER
     ══════════════════════════════════════════════ */
  var vizCanvas = document.getElementById('vizCanvas');
  var vizCtx = vizCanvas.getContext('2d');
  var vizAnimId = null;

  function resizeVizCanvas() {
    vizCanvas.width = vizCanvas.clientWidth * (window.devicePixelRatio || 1);
    vizCanvas.height = vizCanvas.clientHeight * (window.devicePixelRatio || 1);
  }

  function drawVisualizer() {
    vizAnimId = requestAnimationFrame(drawVisualizer);
    if (!analyser) return;

    var w = vizCanvas.width;
    var h = vizCanvas.height;
    var bufLen = analyser.frequencyBinCount;
    var dataArray = new Uint8Array(bufLen);
    analyser.getByteTimeDomainData(dataArray);

    var isDark = document.body.classList.contains('tt-dark');
    vizCtx.fillStyle = isDark ? '#0d0d1a' : '#e0e0ea';
    vizCtx.fillRect(0, 0, w, h);

    vizCtx.lineWidth = 2 * (window.devicePixelRatio || 1);
    vizCtx.strokeStyle = '#e94560';
    vizCtx.beginPath();

    var sliceWidth = w / bufLen;
    var x = 0;
    for (var i = 0; i < bufLen; i++) {
      var v = dataArray[i] / 128.0;
      var y = v * h / 2;
      if (i === 0) vizCtx.moveTo(x, y);
      else vizCtx.lineTo(x, y);
      x += sliceWidth;
    }

    vizCtx.lineTo(w, h / 2);
    vizCtx.stroke();
  }

  /* ══════════════════════════════════════════════
     11. WAV EXPORT
     ══════════════════════════════════════════════ */
  function exportWav() {
    ensureAudio();
    showToast('WAVを生成中...');

    var stepDur = 60.0 / state.bpm / 4;
    var chain = chainQueue.length > 0 ? chainQueue : [state.activePattern];
    var totalSteps = chain.length * NUM_STEPS;
    var duration = totalSteps * stepDur + 1; // +1s for decay tails

    var sampleRate = 44100;
    var offlineCtx = new OfflineAudioContext(2, Math.ceil(sampleRate * duration), sampleRate);

    // Create noise buffer for offline context
    var offNoiseBuf = offlineCtx.createBuffer(1, sampleRate * 2, sampleRate);
    var offNoiseData = offNoiseBuf.getChannelData(0);
    for (var i = 0; i < offNoiseData.length; i++) {
      offNoiseData[i] = Math.random() * 2 - 1;
    }

    var offGain = offlineCtx.createGain();
    offGain.gain.value = 0.8;
    offGain.connect(offlineCtx.destination);

    // Schedule all steps
    var time = 0;
    for (var ci = 0; ci < chain.length; ci++) {
      var patData = state.patterns[chain[ci]];
      for (var s = 0; s < NUM_STEPS; s++) {
        var swingOff = (s % 2 === 1) ? stepDur * (state.swing / 100) * 0.33 : 0;
        var t = time + swingOff;
        for (var tr = 0; tr < NUM_TRACKS; tr++) {
          if (patData[tr][s] && isTrackAudible(tr)) {
            playSound(offlineCtx, offGain, offNoiseBuf, tr, t, state.trackVolume[tr], state.trackPitch[tr]);
          }
        }
        time += stepDur;
      }
    }

    offlineCtx.startRendering().then(function (buffer) {
      var wav = audioBufferToWav(buffer);
      var blob = new Blob([wav], { type: 'audio/wav' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'drum-pattern-' + PATTERNS[state.activePattern] + '-' + state.bpm + 'bpm.wav';
      a.click();
      URL.revokeObjectURL(url);
      showToast('WAVをダウンロードしました');
    }).catch(function () {
      showToast('WAV生成に失敗しました');
    });
  }

  function audioBufferToWav(buffer) {
    var numChannels = buffer.numberOfChannels;
    var sampleRate = buffer.sampleRate;
    var format = 1; // PCM
    var bitDepth = 16;

    var channels = [];
    for (var c = 0; c < numChannels; c++) {
      channels.push(buffer.getChannelData(c));
    }

    var interleaved;
    if (numChannels === 2) {
      var length = channels[0].length + channels[1].length;
      interleaved = new Float32Array(length);
      var idx = 0;
      for (var i = 0; i < channels[0].length; i++) {
        interleaved[idx++] = channels[0][i];
        interleaved[idx++] = channels[1][i];
      }
    } else {
      interleaved = channels[0];
    }

    var dataLength = interleaved.length * (bitDepth / 8);
    var headerLength = 44;
    var totalLength = headerLength + dataLength;
    var arrayBuffer = new ArrayBuffer(totalLength);
    var view = new DataView(arrayBuffer);

    // RIFF header
    writeString(view, 0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    writeString(view, 8, 'WAVE');

    // fmt chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
    view.setUint16(32, numChannels * (bitDepth / 8), true);
    view.setUint16(34, bitDepth, true);

    // data chunk
    writeString(view, 36, 'data');
    view.setUint32(40, dataLength, true);

    // PCM samples
    var offset = 44;
    for (var j = 0; j < interleaved.length; j++) {
      var sample = Math.max(-1, Math.min(1, interleaved[j]));
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }

    return arrayBuffer;
  }

  function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  /* ══════════════════════════════════════════════
     12. SAVE / LOAD / SHARE
     ══════════════════════════════════════════════ */
  var STORAGE_KEY = 'tt-drum-machine';

  function getStateForSave() {
    return {
      bpm: state.bpm,
      swing: state.swing,
      activePattern: state.activePattern,
      patterns: state.patterns,
      trackVolume: state.trackVolume,
      trackPitch: state.trackPitch,
      trackMute: state.trackMute,
      trackSolo: state.trackSolo
    };
  }

  function applyLoadedState(data) {
    if (data.bpm) setBpm(data.bpm);
    if (typeof data.swing === 'number') {
      state.swing = data.swing;
      swingSlider.value = state.swing;
      swingValue.textContent = state.swing + '%';
    }
    if (typeof data.activePattern === 'number') state.activePattern = data.activePattern;
    if (data.patterns) state.patterns = data.patterns;
    if (data.trackVolume) state.trackVolume = data.trackVolume;
    if (data.trackPitch) state.trackPitch = data.trackPitch;
    if (data.trackMute) state.trackMute = data.trackMute;
    if (data.trackSolo) state.trackSolo = data.trackSolo;

    updatePatternBtns();
    updateGridUI();
    updateTrackControls();
    restoreVolumeSliders();
  }

  function restoreVolumeSliders() {
    var sliders = document.querySelectorAll('input[data-ctrl="vol"]');
    sliders.forEach(function (slider) {
      var t = parseInt(slider.dataset.track);
      slider.value = String(state.trackVolume[t] * 100);
    });
  }

  function saveToLocalStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(getStateForSave()));
      showToast('パターンを保存しました');
    } catch (e) {
      showToast('保存に失敗しました');
    }
  }

  function loadFromLocalStorage() {
    try {
      var raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        applyLoadedState(JSON.parse(raw));
        showToast('パターンを読み込みました');
      } else {
        showToast('保存データがありません');
      }
    } catch (e) {
      showToast('読み込みに失敗しました');
    }
  }

  function saveToFile() {
    var data = JSON.stringify(getStateForSave(), null, 2);
    var blob = new Blob([data], { type: 'application/json' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'drum-pattern.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('JSONファイルを保存しました');
  }

  function loadFromFile() {
    loadFile.click();
  }

  function handleFileLoad(e) {
    var file = e.target.files[0];
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function (ev) {
      try {
        var data = JSON.parse(ev.target.result);
        applyLoadedState(data);
        showToast('ファイルから読み込みました');
      } catch (err) {
        showToast('ファイルの読み込みに失敗しました');
      }
    };
    reader.readAsText(file);
    loadFile.value = '';
  }

  function shareUrl() {
    try {
      var data = JSON.stringify(getStateForSave());
      var encoded = btoa(unescape(encodeURIComponent(data)));
      var url = location.origin + location.pathname + '#' + encoded;
      navigator.clipboard.writeText(url).then(function () {
        showToast('共有URLをコピーしました');
      }).catch(function () {
        showToast('URLのコピーに失敗しました');
      });
    } catch (e) {
      showToast('共有URLの生成に失敗しました');
    }
  }

  function loadFromHash() {
    if (!location.hash || location.hash.length < 2) return;
    try {
      var decoded = decodeURIComponent(escape(atob(location.hash.substring(1))));
      var data = JSON.parse(decoded);
      applyLoadedState(data);
    } catch (e) {
      // ignore invalid hash
    }
  }

  /* ══════════════════════════════════════════════
     13. KEYBOARD SHORTCUTS
     ══════════════════════════════════════════════ */
  function handleKeydown(e) {
    // Skip if typing in an input
    var tag = (e.target.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

    switch (e.key) {
      case ' ':
        e.preventDefault();
        togglePlayback();
        break;
      case '1': case '2': case '3': case '4':
        switchPattern(parseInt(e.key) - 1);
        break;
      case '+': case '=':
        setBpm(state.bpm + 5);
        break;
      case '-': case '_':
        setBpm(state.bpm - 5);
        break;
    }

    // Ctrl+S = save
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      saveToLocalStorage();
    }
    // Ctrl+E = export WAV
    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
      e.preventDefault();
      exportWav();
    }
  }

  /* ══════════════════════════════════════════════
     14. TOAST
     ══════════════════════════════════════════════ */
  var toastTimer;
  function showToast(msg) {
    var el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(function () {
      el.classList.remove('show');
    }, 2000);
  }

  /* ══════════════════════════════════════════════
     15. INIT
     ══════════════════════════════════════════════ */
  // DOM references
  var playBtn = document.getElementById('playBtn');
  var bpmInput = document.getElementById('bpmInput');
  var bpmDownBtn = document.getElementById('bpmDown');
  var bpmUpBtn = document.getElementById('bpmUp');
  var swingSlider = document.getElementById('swingSlider');
  var swingValue = document.getElementById('swingValue');
  var chainInput = document.getElementById('chainInput');
  var loadFile = document.getElementById('loadFile');

  // Build UI
  buildPatternBtns();
  buildGrid();
  resizeVizCanvas();

  // Event listeners — transport
  playBtn.addEventListener('click', togglePlayback);
  bpmInput.addEventListener('change', function () {
    var val = parseInt(bpmInput.value);
    if (!isNaN(val)) {
      setBpm(val);
    } else {
      bpmInput.value = state.bpm;
    }
  });
  bpmInput.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') { bpmInput.blur(); }
  });
  bpmDownBtn.addEventListener('click', function () { setBpm(state.bpm - 5); });
  bpmUpBtn.addEventListener('click', function () { setBpm(state.bpm + 5); });
  swingSlider.addEventListener('input', function () {
    state.swing = parseInt(swingSlider.value);
    swingValue.textContent = state.swing + '%';
  });

  // Event listeners — pattern bar
  document.getElementById('patternBtns').addEventListener('click', function (e) {
    var btn = e.target.closest('.pattern-btn');
    if (btn) switchPattern(parseInt(btn.dataset.pattern));
  });
  document.getElementById('copyBtn').addEventListener('click', copyPattern);
  document.getElementById('pasteBtn').addEventListener('click', pastePattern);
  document.getElementById('clearBtn').addEventListener('click', clearPattern);

  // Event listeners — sequencer (delegation)
  var sequencerEl = document.getElementById('sequencer');
  sequencerEl.addEventListener('click', handleSequencerClick);
  sequencerEl.addEventListener('input', handleSequencerInput);

  // Event listeners — footer
  document.getElementById('exportWav').addEventListener('click', exportWav);
  document.getElementById('saveBtn').addEventListener('click', function () {
    saveToLocalStorage();
    saveToFile();
  });
  document.getElementById('loadBtn').addEventListener('click', loadFromFile);
  loadFile.addEventListener('change', handleFileLoad);
  document.getElementById('shareBtn').addEventListener('click', shareUrl);

  // Keyboard
  document.addEventListener('keydown', handleKeydown);

  // Visualizer
  window.addEventListener('resize', resizeVizCanvas);
  drawVisualizer();

  // Load from URL hash or localStorage
  loadFromHash();
  if (!location.hash || location.hash.length < 2) {
    var saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      try {
        applyLoadedState(JSON.parse(saved));
      } catch (e) { /* ignore */ }
    }
  }

  // Auto-save on unload
  window.addEventListener('beforeunload', function () {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(getStateForSave()));
    } catch (e) { /* ignore */ }
  });

})();
</script>
</body>
</html>
