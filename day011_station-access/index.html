<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>駅アクセスチェッカー | tiny-tools Day 11</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
      background: #f5f5f5; color: #333; min-height: 100vh;
      display: flex; flex-direction: column; align-items: center;
    }
    .container { width: 100%; max-width: 760px; padding: 1rem; }
    h1 { font-size: 1.4rem; margin-bottom: .3rem; }
    .app-desc { font-size: .85rem; color: #888; margin-bottom: 1.2rem; }

    /* Search card */
    .card {
      background: #fff; border-radius: 12px; padding: 1.25rem;
      box-shadow: 0 1px 4px rgba(0,0,0,.08); margin-bottom: 1rem;
    }
    .card-title { font-size: 1rem; font-weight: 600; margin-bottom: .8rem; }

    /* Origins table */
    .origins-table {
      width: 100%; border-collapse: separate; border-spacing: 0;
    }
    .origins-table th {
      font-size: .75rem; font-weight: 500; color: #888; text-align: left;
      padding: 0 .3rem .4rem; white-space: nowrap;
    }
    .origins-table td {
      padding: .2rem .3rem; vertical-align: middle;
    }
    .origins-table td:first-child { padding-left: 0; }
    .origins-table td:last-child { padding-right: 0; }
    .col-station { width: auto; }
    .col-transfers { width: 72px; }
    .col-minutes { width: 72px; }
    .col-remove { width: 36px; }

    .origin-input-wrap { position: relative; }
    .origin-input {
      width: 100%; padding: .45rem .6rem; border: 1px solid #d0d0d0;
      border-radius: 6px; font-size: .85rem; font-family: inherit;
      outline: none; transition: border-color .15s;
    }
    .origin-input:focus { border-color: #4a90d9; }
    .origin-input.has-value { border-color: #4a90d9; background: #f0f6ff; }

    .cond-number {
      width: 100%; padding: .35rem .3rem; border: 1px solid #d0d0d0;
      border-radius: 6px; font-size: .85rem; font-family: inherit;
      text-align: center; outline: none;
    }
    .cond-number:focus { border-color: #4a90d9; }
    .cond-number:disabled { opacity: .4; }

    .remove-origin {
      background: none; border: 1px solid #e0e0e0; border-radius: 6px;
      color: #999; cursor: pointer; padding: .3rem .45rem; font-size: .8rem;
      transition: color .15s, border-color .15s; line-height: 1;
    }
    .remove-origin:hover { color: #e55; border-color: #e55; }

    /* Autocomplete dropdown */
    .ac-dropdown {
      display: none; position: absolute; left: 0; right: 0; top: 100%;
      background: #fff; border: 1px solid #d0d0d0; border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,.12); max-height: 240px;
      overflow-y: auto; z-index: 100; margin-top: 2px;
    }
    .ac-dropdown.open { display: block; }
    .ac-item {
      padding: .5rem .75rem; cursor: pointer; font-size: .9rem;
      display: flex; justify-content: space-between; align-items: center;
      transition: background .1s;
    }
    .ac-item:hover, .ac-item.active { background: #f0f6ff; }
    .ac-item-name { font-weight: 500; }
    .ac-item-lines { font-size: .75rem; color: #888; }
    .ac-item-pref { font-size: .75rem; color: #aaa; margin-left: .5rem; }

    .btn-row { display: flex; gap: .5rem; margin-top: .75rem; flex-wrap: wrap; }
    .btn-add {
      background: none; border: 1px dashed #4a90d9; color: #4a90d9;
      padding: .5rem 1rem; border-radius: 8px; cursor: pointer;
      font-size: .85rem; font-family: inherit; transition: background .15s;
    }
    .btn-add:hover { background: #f0f6ff; }
    .btn-search {
      background: #4a90d9; color: #fff; border: none; padding: .55rem 1.5rem;
      border-radius: 8px; cursor: pointer; font-size: .95rem; font-weight: 600;
      font-family: inherit; transition: background .15s;
    }
    .btn-search:hover { background: #3a7bc0; }
    .btn-search:disabled { background: #aaa; cursor: not-allowed; }

    /* Results */
    .result-header {
      display: flex; justify-content: space-between; align-items: center;
      flex-wrap: wrap; gap: .5rem; margin-bottom: .75rem;
    }
    .result-count { font-size: .95rem; font-weight: 600; }
    .result-controls { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
    .result-controls select {
      padding: .3rem .5rem; border: 1px solid #d0d0d0; border-radius: 6px;
      font-size: .8rem; font-family: inherit; background: #fff; cursor: pointer;
    }
    .sort-dir-btn {
      padding: .3rem .5rem; border: 1px solid #d0d0d0; border-radius: 6px;
      font-size: .8rem; font-family: inherit; background: #fff; cursor: pointer;
      white-space: nowrap;
    }
    .sort-dir-btn:hover { border-color: #4a90d9; }

    .station-list { list-style: none; }
    .station-item {
      background: #fff; border-radius: 10px; padding: 1rem 1.1rem;
      margin-bottom: .6rem; box-shadow: 0 1px 3px rgba(0,0,0,.06);
      transition: box-shadow .15s; cursor: pointer;
    }
    .station-item:hover { box-shadow: 0 2px 8px rgba(0,0,0,.1); }
    .station-top {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: .4rem;
    }
    .station-name { font-size: 1.05rem; font-weight: 600; }
    .station-pref { font-size: .8rem; color: #888; }
    .line-badges { display: flex; flex-wrap: wrap; gap: .3rem; margin-bottom: .5rem; }
    .line-badge {
      display: inline-flex; align-items: center; gap: .25rem;
      padding: .15rem .5rem; border-radius: 999px; font-size: .75rem;
      font-weight: 500; color: #fff; white-space: nowrap;
    }
    .line-dot {
      width: 8px; height: 8px; border-radius: 50%; background: currentColor;
    }
    .access-info { font-size: .82rem; color: #555; }
    .access-line {
      display: flex; gap: .5rem; align-items: center;
      padding: .15rem 0; flex-wrap: wrap;
    }
    .access-origin { font-weight: 500; min-width: 80px; }
    .access-detail { color: #4a90d9; }

    /* Paging */
    .paging {
      display: flex; justify-content: center; gap: .5rem; margin-top: 1rem;
      flex-wrap: wrap;
    }
    .paging button {
      padding: .4rem .8rem; border: 1px solid #d0d0d0; border-radius: 6px;
      background: #fff; cursor: pointer; font-size: .85rem; font-family: inherit;
      transition: background .15s, border-color .15s;
    }
    .paging button:hover { border-color: #4a90d9; }
    .paging button.active { background: #4a90d9; color: #fff; border-color: #4a90d9; }
    .paging button:disabled { opacity: .4; cursor: not-allowed; }

    /* Loading */
    .loading {
      text-align: center; padding: 2rem; color: #888; font-size: .9rem;
    }
    .loading-spinner {
      width: 28px; height: 28px; border: 3px solid #e0e0e0;
      border-top-color: #4a90d9; border-radius: 50%;
      animation: spin .7s linear infinite; margin: 0 auto .8rem;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Share button */
    .btn-share {
      background: none; border: 1px solid #d0d0d0; color: #555;
      padding: .35rem .75rem; border-radius: 6px; cursor: pointer;
      font-size: .8rem; font-family: inherit; transition: background .15s;
    }
    .btn-share:hover { background: #f0f6ff; border-color: #4a90d9; color: #4a90d9; }

    /* Empty state */
    .no-results { text-align: center; padding: 2rem; color: #888; font-size: .9rem; }

    /* Detail view */
    #detail-view { display: none; }
    .btn-back {
      background: none; border: 1px solid #d0d0d0; color: #555;
      padding: .45rem .9rem; border-radius: 8px; cursor: pointer;
      font-size: .85rem; font-family: inherit; transition: background .15s;
      margin-bottom: 1rem;
    }
    .btn-back:hover { background: #f0f6ff; border-color: #4a90d9; color: #4a90d9; }

    .detail-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: .5rem;
    }
    .detail-station-name { font-size: 1.3rem; font-weight: 700; }
    .detail-pref { font-size: .85rem; color: #888; }

    #map-container {
      width: 100%; height: 400px; border-radius: 10px; overflow: hidden;
      margin-bottom: 1rem; box-shadow: 0 1px 4px rgba(0,0,0,.1);
    }

    .route-section { margin-top: .5rem; }
    .route-section-title { font-size: 1rem; font-weight: 600; margin-bottom: .75rem; }

    .route-card {
      background: #fff; border-radius: 10px; padding: 1rem 1.1rem;
      margin-bottom: .75rem; box-shadow: 0 1px 3px rgba(0,0,0,.06);
    }
    .route-card-header {
      font-size: .95rem; font-weight: 600; margin-bottom: .5rem;
      display: flex; justify-content: space-between; align-items: center;
    }
    .route-summary { font-size: .82rem; color: #4a90d9; }

    .route-timeline { padding-left: .5rem; }
    .route-segment {
      display: flex; gap: .6rem; margin-bottom: .4rem;
      font-size: .82rem; color: #555;
    }
    .segment-line-bar {
      width: 4px; border-radius: 2px; flex-shrink: 0; min-height: 24px;
    }
    .segment-content { flex: 1; }
    .segment-line-name { font-weight: 600; margin-bottom: .15rem; }
    .segment-stations { color: #888; font-size: .78rem; }
    .segment-transfer {
      font-size: .78rem; color: #999; padding: .15rem 0 .15rem .5rem;
      border-left: 2px dashed #d0d0d0; margin-left: 1.5px; margin-bottom: .4rem;
    }

    /* View toggle */
    .view-toggle {
      display: inline-flex; border: 1px solid #d0d0d0; border-radius: 6px; overflow: hidden;
    }
    .view-toggle button {
      padding: .3rem .7rem; border: none; background: #fff; cursor: pointer;
      font-size: .8rem; font-family: inherit; color: #555; transition: background .15s, color .15s;
    }
    .view-toggle button:not(:last-child) { border-right: 1px solid #d0d0d0; }
    .view-toggle button.active { background: #4a90d9; color: #fff; }

    /* Map grayscale */
    .leaflet-tile-pane { filter: grayscale(100%); }

    #results-map-container {
      width: 100%; height: 450px; border-radius: 10px; overflow: hidden;
      margin-top: .75rem; box-shadow: 0 1px 4px rgba(0,0,0,.1);
    }

    /* Dark mode */
    body.tt-dark { background: #1a1a2e; color: #e0e0e0; }
    body.tt-dark .card { background: #20203a; box-shadow: 0 1px 4px rgba(0,0,0,.2); }
    body.tt-dark .origins-table th { color: #888; }
    body.tt-dark .origin-input {
      background: #252545; color: #e0e0e0; border-color: #3a3a5a;
    }
    body.tt-dark .origin-input:focus { border-color: #6ab0f3; }
    body.tt-dark .origin-input.has-value { background: #252550; border-color: #6ab0f3; }
    body.tt-dark .ac-dropdown {
      background: #252545; border-color: #3a3a5a;
      box-shadow: 0 4px 16px rgba(0,0,0,.3);
    }
    body.tt-dark .ac-item:hover, body.tt-dark .ac-item.active { background: #303060; }
    body.tt-dark .ac-item-name { color: #e0e0e0; }
    body.tt-dark .cond-number {
      background: #252545; color: #e0e0e0; border-color: #3a3a5a;
    }
    body.tt-dark .remove-origin { border-color: #3a3a5a; color: #777; }
    body.tt-dark .remove-origin:hover { color: #f66; border-color: #f66; }
    body.tt-dark .btn-add { border-color: #6ab0f3; color: #6ab0f3; }
    body.tt-dark .btn-add:hover { background: rgba(106,176,243,.1); }
    body.tt-dark .station-item { background: #20203a; box-shadow: 0 1px 3px rgba(0,0,0,.15); }
    body.tt-dark .station-name { color: #f0f0f0; }
    body.tt-dark .station-pref { color: #999; }
    body.tt-dark .access-info { color: #bbb; }
    body.tt-dark .access-detail { color: #6ab0f3; }
    body.tt-dark .result-controls select {
      background: #252545; color: #e0e0e0; border-color: #3a3a5a;
    }
    body.tt-dark .sort-dir-btn {
      background: #252545; color: #e0e0e0; border-color: #3a3a5a;
    }
    body.tt-dark .sort-dir-btn:hover { border-color: #6ab0f3; }
    body.tt-dark .paging button {
      background: #252545; color: #e0e0e0; border-color: #3a3a5a;
    }
    body.tt-dark .paging button:hover { border-color: #6ab0f3; }
    body.tt-dark .paging button.active {
      background: #4a90d9; color: #fff; border-color: #4a90d9;
    }
    body.tt-dark .btn-share { border-color: #3a3a5a; color: #999; }
    body.tt-dark .btn-share:hover { background: rgba(106,176,243,.1); border-color: #6ab0f3; color: #6ab0f3; }
    body.tt-dark .btn-back { border-color: #3a3a5a; color: #999; }
    body.tt-dark .btn-back:hover { background: rgba(106,176,243,.1); border-color: #6ab0f3; color: #6ab0f3; }
    body.tt-dark .route-card { background: #20203a; box-shadow: 0 1px 3px rgba(0,0,0,.15); }
    body.tt-dark .route-card-header { color: #f0f0f0; }
    body.tt-dark .route-summary { color: #6ab0f3; }
    body.tt-dark .route-segment { color: #bbb; }
    body.tt-dark .segment-stations { color: #888; }
    body.tt-dark .segment-transfer { color: #777; border-left-color: #3a3a5a; }
    body.tt-dark .detail-station-name { color: #f0f0f0; }
    body.tt-dark #map-container { box-shadow: 0 1px 4px rgba(0,0,0,.3); }
    body.tt-dark #results-map-container { box-shadow: 0 1px 4px rgba(0,0,0,.3); }
    body.tt-dark .view-toggle { border-color: #3a3a5a; }
    body.tt-dark .view-toggle button { background: #252545; color: #999; border-color: #3a3a5a; }
    body.tt-dark .view-toggle button.active { background: #4a90d9; color: #fff; }

    body.tt-dark .leaflet-control-attribution {
      background: rgba(32,32,58,.8) !important; color: #888 !important;
    }
    body.tt-dark .leaflet-control-attribution a { color: #6ab0f3 !important; }
    body.tt-dark .leaflet-control-zoom a {
      background: #20203a !important; color: #e0e0e0 !important;
      border-color: #3a3a5a !important;
    }

    @media (max-width: 500px) {
      .container { padding: .75rem; }
      .station-item { padding: .8rem; }
      #map-container { height: 300px; }
    }
  </style>
  <script src="../shared/header.js" data-repo="https://github.com/sanasuke/tiny-tools"></script>
  <script src="data.js"></script>
</head>
<body>
  <div class="container">
    <h1>駅アクセスチェッカー</h1>
    <p class="app-desc">所要時間は概算です（路線ごとの平均駅間時間＋乗換5分で計算）</p>

    <div id="search-view">
      <div class="card" id="search-card">
        <div class="card-title">検索条件</div>
        <table class="origins-table">
          <thead><tr>
            <th class="col-station">駅名</th>
            <th class="col-transfers">乗換回数</th>
            <th class="col-minutes">所要時間</th>
            <th class="col-remove"></th>
          </tr></thead>
          <tbody id="origins"></tbody>
        </table>
        <div class="btn-row">
          <button class="btn-add" id="btn-add-origin">+ 出発地を追加</button>
          <button class="btn-search" id="btn-search">検索</button>
        </div>
      </div>

      <div id="results-area"></div>
    </div>

    <div id="detail-view">
      <button class="btn-back" id="btn-back">&larr; 検索結果に戻る</button>
      <div id="detail-content"></div>
    </div>
  </div>

  <script>
  (function () {
    'use strict';

    /* ========== Data Structures ========== */
    var RD = window.RAIL_DATA;
    if (!RD) { document.getElementById('results-area').innerHTML = '<div class="no-results">鉄道データの読み込みに失敗しました</div>'; return; }

    // stationMap: sid -> {id, name, kana, groupId, pref, lat, lon, lines:[lineId...]}
    var stationMap = {};
    // groupMap: groupId -> [sid, ...]
    var groupMap = {};
    // lineMap: lineId -> {id, name, color, stationIds:[], interval}
    var lineMap = {};
    // adjacency: sid -> [{neighbor: sid, lineId}]
    var adjacency = {};
    // circularSet
    var circularSet = {};
    // groupInfo: groupId -> {id, name, kana, pref, lines:[{id,name,color}], sids:[]}
    var groupInfo = {};

    // Build lineMap
    RD.lines.forEach(function (l) {
      lineMap[l[0]] = { id: l[0], name: l[1], color: l[2], stationIds: l[3], interval: l[4] || 2.5 };
    });

    // Build stationMap (now with lat/lon at indices 5,6)
    RD.stations.forEach(function (s) {
      stationMap[s[0]] = { id: s[0], name: s[1], kana: s[2], groupId: s[3], pref: s[4], lat: s[5] || 0, lon: s[6] || 0, lines: [] };
      if (!groupMap[s[3]]) groupMap[s[3]] = [];
      groupMap[s[3]].push(s[0]);
    });

    // Circular set
    RD.circular.forEach(function (lid) { circularSet[lid] = true; });

    // Assign lines to stations & build adjacency
    RD.lines.forEach(function (l) {
      var lineId = l[0];
      var sids = l[3];
      var isCirc = !!circularSet[lineId];

      sids.forEach(function (sid) {
        if (stationMap[sid]) stationMap[sid].lines.push(lineId);
        if (!adjacency[sid]) adjacency[sid] = [];
      });

      for (var i = 0; i < sids.length; i++) {
        if (i > 0) {
          adjacency[sids[i]].push({ neighbor: sids[i - 1], lineId: lineId });
        }
        if (i < sids.length - 1) {
          adjacency[sids[i]].push({ neighbor: sids[i + 1], lineId: lineId });
        }
      }
      // Circular: connect last to first
      if (isCirc && sids.length > 2) {
        adjacency[sids[0]].push({ neighbor: sids[sids.length - 1], lineId: lineId });
        adjacency[sids[sids.length - 1]].push({ neighbor: sids[0], lineId: lineId });
      }
    });

    // Build groupInfo (for display and search)
    Object.keys(groupMap).forEach(function (gid) {
      var sids = groupMap[gid];
      var first = stationMap[sids[0]];
      var lineSet = {};
      var lines = [];
      sids.forEach(function (sid) {
        var st = stationMap[sid];
        st.lines.forEach(function (lid) {
          if (!lineSet[lid]) {
            lineSet[lid] = true;
            var li = lineMap[lid];
            if (li) lines.push({ id: li.id, name: li.name, color: li.color });
          }
        });
      });
      groupInfo[gid] = {
        id: gid,
        name: first.name,
        kana: first.kana,
        pref: first.pref,
        lines: lines,
        sids: sids
      };
    });

    // Search index: array of {gid, name, kana, pref}
    var searchIndex = [];
    Object.keys(groupInfo).forEach(function (gid) {
      var g = groupInfo[gid];
      var kana = g.kana || '';
      searchIndex.push({
        gid: gid,
        name: g.name,
        kana: kana,
        kanaHira: kana ? katakanaToHiragana(kana) : '',
        pref: g.pref
      });
    });

    // Sort searchIndex: stations with more lines first (major hubs appear earlier)
    searchIndex.sort(function (a, b) {
      return (groupInfo[b.gid].lines.length) - (groupInfo[a.gid].lines.length);
    });

    function katakanaToHiragana(str) {
      return str.replace(/[\u30A1-\u30F6]/g, function (m) {
        return String.fromCharCode(m.charCodeAt(0) - 0x60);
      });
    }

    /* ========== Autocomplete ========== */
    function searchStations(query, limit) {
      if (!query) return [];
      limit = limit || 20;
      var q = query.toLowerCase();
      var qHira = katakanaToHiragana(q);
      var exact = [];
      var prefix = [];
      var partial = [];

      for (var i = 0; i < searchIndex.length; i++) {
        var s = searchIndex[i];
        var nameMatch = s.name.indexOf(q) !== -1;
        var kanaMatch = s.kana && s.kana.toLowerCase().indexOf(q) !== -1;
        var hiraMatch = s.kanaHira && s.kanaHira.indexOf(qHira) !== -1;

        if (!nameMatch && !kanaMatch && !hiraMatch) continue;

        if (s.name === q) { exact.push(s); }
        else if (s.name.indexOf(q) === 0) { prefix.push(s); }
        else { partial.push(s); }

        if (exact.length + prefix.length + partial.length >= limit * 2) break;
      }
      return exact.concat(prefix).concat(partial).slice(0, limit);
    }

    /* ========== BFS / Dijkstra ========== */
    function MinHeap() { this.data = []; }
    MinHeap.prototype.push = function (item) {
      this.data.push(item);
      this._bubbleUp(this.data.length - 1);
    };
    MinHeap.prototype.pop = function () {
      var top = this.data[0];
      var last = this.data.pop();
      if (this.data.length > 0) { this.data[0] = last; this._sinkDown(0); }
      return top;
    };
    MinHeap.prototype.size = function () { return this.data.length; };
    MinHeap.prototype._bubbleUp = function (i) {
      while (i > 0) {
        var p = (i - 1) >> 1;
        if (this.data[p].cost <= this.data[i].cost) break;
        var tmp = this.data[p]; this.data[p] = this.data[i]; this.data[i] = tmp;
        i = p;
      }
    };
    MinHeap.prototype._sinkDown = function (i) {
      var n = this.data.length;
      while (true) {
        var l = 2 * i + 1, r = 2 * i + 2, smallest = i;
        if (l < n && this.data[l].cost < this.data[smallest].cost) smallest = l;
        if (r < n && this.data[r].cost < this.data[smallest].cost) smallest = r;
        if (smallest === i) break;
        var tmp = this.data[smallest]; this.data[smallest] = this.data[i]; this.data[i] = tmp;
        i = smallest;
      }
    };

    /**
     * Combined search: finds reachable stations from an origin group.
     * Returns: { groupId -> { transfers, minutes } }
     */
    function searchReachable(originGroupId, maxTransfers, maxMinutes) {
      if (maxTransfers === null && maxMinutes === null) return {};
      var mt = maxTransfers !== null ? maxTransfers : 99;
      var mm = maxMinutes !== null ? maxMinutes : 9999;

      var originSids = groupMap[originGroupId] || [];
      if (originSids.length === 0) return {};

      var best = {};
      function key(sid, t) { return sid + '_' + t; }

      var heap = new MinHeap();

      originSids.forEach(function (sid) {
        var st = stationMap[sid];
        if (!st) return;
        st.lines.forEach(function (lid) {
          var k = key(sid, 0);
          if (best[k] === undefined || best[k] > 0) {
            best[k] = 0;
            heap.push({ sid: sid, lineId: lid, transfers: 0, cost: 0 });
          }
        });
      });

      var groupResults = {};

      while (heap.size() > 0) {
        var cur = heap.pop();
        var cSid = cur.sid, cLine = cur.lineId, cT = cur.transfers, cMin = cur.cost;

        if (cT > mt || cMin > mm) continue;
        var k = key(cSid, cT);
        if (best[k] !== undefined && best[k] < cMin) continue;

        var gid = stationMap[cSid].groupId;
        var existing = groupResults[gid];
        if (!existing || cMin < existing.minutes || (cMin === existing.minutes && cT < existing.transfers)) {
          groupResults[gid] = { transfers: cT, minutes: cMin };
        }

        var lineInterval = lineMap[cLine] ? lineMap[cLine].interval : 2.5;
        var adj = adjacency[cSid] || [];
        for (var i = 0; i < adj.length; i++) {
          if (adj[i].lineId !== cLine) continue;
          var nSid = adj[i].neighbor;
          var nMin = cMin + lineInterval;
          if (nMin > mm) continue;
          var nk = key(nSid, cT);
          if (best[nk] === undefined || best[nk] > nMin) {
            best[nk] = nMin;
            heap.push({ sid: nSid, lineId: cLine, transfers: cT, cost: nMin });
          }
        }

        var nT = cT + 1;
        if (nT <= mt) {
          var gSids = groupMap[gid] || [];
          for (var g = 0; g < gSids.length; g++) {
            var tSid = gSids[g];
            var tSt = stationMap[tSid];
            if (!tSt) continue;
            for (var li = 0; li < tSt.lines.length; li++) {
              var tLine = tSt.lines[li];
              if (tSid === cSid && tLine === cLine) continue;
              var tMin = cMin + 5;
              if (tMin > mm) continue;
              var tk = key(tSid, nT);
              if (best[tk] === undefined || best[tk] > tMin) {
                best[tk] = tMin;
                heap.push({ sid: tSid, lineId: tLine, transfers: nT, cost: tMin });
              }
            }
          }
        }
      }

      return groupResults;
    }

    /* ========== Path Finding (Dijkstra with parent pointers) ========== */
    function findPath(originGroupId, targetGroupId, maxTransfers, maxMinutes) {
      var mt = maxTransfers !== null ? maxTransfers : 99;
      var mm = maxMinutes !== null ? maxMinutes : 9999;

      var originSids = groupMap[originGroupId] || [];
      var targetSids = groupMap[targetGroupId] || [];
      if (originSids.length === 0 || targetSids.length === 0) return null;

      var targetSidSet = {};
      targetSids.forEach(function (sid) { targetSidSet[sid] = true; });

      var best = {};
      var parent = {}; // key -> {parentSid, parentTransfers, parentLineId, isTransfer}
      function key(sid, t) { return sid + '_' + t; }

      var heap = new MinHeap();

      originSids.forEach(function (sid) {
        var st = stationMap[sid];
        if (!st) return;
        st.lines.forEach(function (lid) {
          var k = key(sid, 0);
          if (best[k] === undefined || best[k] > 0) {
            best[k] = 0;
            heap.push({ sid: sid, lineId: lid, transfers: 0, cost: 0 });
            parent[k] = null; // origin
          }
        });
      });

      var foundKey = null;
      var foundCost = Infinity;

      while (heap.size() > 0) {
        var cur = heap.pop();
        var cSid = cur.sid, cLine = cur.lineId, cT = cur.transfers, cMin = cur.cost;

        if (cMin > foundCost) break;
        if (cT > mt || cMin > mm) continue;
        var k = key(cSid, cT);
        if (best[k] !== undefined && best[k] < cMin) continue;

        // Check if we reached target
        if (targetSidSet[cSid] && cMin <= foundCost) {
          foundKey = k;
          foundCost = cMin;
        }

        var lineInterval = lineMap[cLine] ? lineMap[cLine].interval : 2.5;
        var adj = adjacency[cSid] || [];
        for (var i = 0; i < adj.length; i++) {
          if (adj[i].lineId !== cLine) continue;
          var nSid = adj[i].neighbor;
          var nMin = cMin + lineInterval;
          if (nMin > mm) continue;
          var nk = key(nSid, cT);
          if (best[nk] === undefined || best[nk] > nMin) {
            best[nk] = nMin;
            parent[nk] = { pSid: cSid, pT: cT, lineId: cLine, isTransfer: false };
            heap.push({ sid: nSid, lineId: cLine, transfers: cT, cost: nMin });
          }
        }

        var nT = cT + 1;
        if (nT <= mt) {
          var gid = stationMap[cSid].groupId;
          var gSids = groupMap[gid] || [];
          for (var g = 0; g < gSids.length; g++) {
            var tSid = gSids[g];
            var tSt = stationMap[tSid];
            if (!tSt) continue;
            for (var li = 0; li < tSt.lines.length; li++) {
              var tLine = tSt.lines[li];
              if (tSid === cSid && tLine === cLine) continue;
              var tMin = cMin + 5;
              if (tMin > mm) continue;
              var tk = key(tSid, nT);
              if (best[tk] === undefined || best[tk] > tMin) {
                best[tk] = tMin;
                parent[tk] = { pSid: cSid, pT: cT, lineId: tLine, isTransfer: true };
                heap.push({ sid: tSid, lineId: tLine, transfers: nT, cost: tMin });
              }
            }
          }
        }
      }

      if (!foundKey) return null;

      // Reconstruct path
      var path = [];
      var ck = foundKey;
      while (ck && parent[ck] !== undefined) {
        var parts = ck.split('_');
        var sid = parseInt(parts[0]);
        var p = parent[ck];
        if (p === null) {
          path.unshift({ sid: sid, lineId: null, isTransfer: false });
          break;
        }
        path.unshift({ sid: sid, lineId: p.lineId, isTransfer: p.isTransfer });
        ck = key(p.pSid, p.pT);
      }

      // Build segments from path
      var segments = [];
      var currentSeg = null;

      for (var pi = 0; pi < path.length; pi++) {
        var step = path[pi];
        var st = stationMap[step.sid];
        if (!st) continue;

        if (pi === 0 || step.isTransfer) {
          // Start new segment
          if (currentSeg) segments.push(currentSeg);
          var effectiveLineId = step.lineId;
          if (effectiveLineId == null && pi + 1 < path.length) {
            effectiveLineId = path[pi + 1].lineId;
          }
          var line = lineMap[effectiveLineId];
          currentSeg = {
            lineId: step.lineId,
            lineName: line ? line.name : '?',
            lineColor: line ? line.color : '999999',
            stations: [{ name: st.name, lat: st.lat, lon: st.lon }]
          };
        } else {
          if (currentSeg) {
            currentSeg.stations.push({ name: st.name, lat: st.lat, lon: st.lon });
          }
        }
      }
      if (currentSeg) segments.push(currentSeg);

      // Calculate total
      var totalT = 0;
      if (segments.length > 1) totalT = segments.length - 1;
      var totalMin = foundCost;

      return { totalMinutes: totalMin, totalTransfers: totalT, segments: segments };
    }

    /* ========== UI State ========== */
    var origins = [];
    var results = null;
    var currentSort = 'minMinutes';
    var currentSortDir = 'asc';
    var currentSortOrigin = '';
    var currentPrefFilter = '';
    var currentPage = 0;
    var PAGE_SIZE = 20;
    var leafletMap = null;
    var resultsMapView = false;
    var resultsLeafletMap = null;
    var currentDetailGid = null;

    /* ========== UI: Elements ========== */
    var searchView = document.getElementById('search-view');
    var detailView = document.getElementById('detail-view');
    var detailContent = document.getElementById('detail-content');
    var originsEl = document.getElementById('origins');
    var btnAdd = document.getElementById('btn-add-origin');
    var btnSearch = document.getElementById('btn-search');
    var resultsArea = document.getElementById('results-area');
    var btnBack = document.getElementById('btn-back');

    /* ========== View Switching ========== */
    function cleanupResultsMap() {
      if (resultsLeafletMap) { resultsLeafletMap.remove(); resultsLeafletMap = null; }
    }

    function showSearchView() {
      searchView.style.display = 'block';
      detailView.style.display = 'none';
      currentDetailGid = null;
      if (leafletMap) { leafletMap.remove(); leafletMap = null; }
    }

    function showDetailView(targetGid) {
      currentDetailGid = targetGid;
      cleanupResultsMap();
      searchView.style.display = 'none';
      detailView.style.display = 'block';
      renderDetailView(targetGid);
    }

    btnBack.addEventListener('click', function () {
      showSearchView();
      saveToHash();
      window.scrollTo(0, 0);
    });

    /* ========== UI: Origins ========== */
    function addOriginRow(presetGroupId, presetName, presetTransfers, presetMinutes) {
      if (origins.length >= 5) return;

      var row = document.createElement('tr');

      var idx = origins.length;
      var origin = {
        groupId: presetGroupId || null,
        name: presetName || '',
        maxTransfers: presetTransfers !== undefined ? presetTransfers : 1,
        maxMinutes: presetMinutes !== undefined ? presetMinutes : null,
        el: row
      };

      // Station name cell
      var tdStation = document.createElement('td');
      var inputWrap = document.createElement('div');
      inputWrap.className = 'origin-input-wrap';

      var input = document.createElement('input');
      input.type = 'text';
      input.className = 'origin-input';
      input.placeholder = '駅名を入力…';
      input.setAttribute('autocomplete', 'off');
      if (presetName) {
        input.value = presetName;
        input.classList.add('has-value');
      }

      var dropdown = document.createElement('div');
      dropdown.className = 'ac-dropdown';

      var activeIdx = -1;
      var acItems = [];

      function showAC(query) {
        var matches = searchStations(query);
        dropdown.innerHTML = '';
        acItems = [];
        activeIdx = -1;
        if (matches.length === 0) { dropdown.classList.remove('open'); return; }
        matches.forEach(function (m) {
          var item = document.createElement('div');
          item.className = 'ac-item';
          var g = groupInfo[m.gid];
          var lineNames = g.lines.slice(0, 3).map(function (l) { return l.name; }).join(', ');
          if (g.lines.length > 3) lineNames += '…';
          item.innerHTML = '<span class="ac-item-name">' + escapeHtml(m.name) + '</span>' +
            '<span><span class="ac-item-lines">' + escapeHtml(lineNames) + '</span>' +
            '<span class="ac-item-pref">' + escapeHtml(RD.prefNames[m.pref] || '') + '</span></span>';
          item.addEventListener('mousedown', function (e) { e.preventDefault(); selectStation(m); });
          dropdown.appendChild(item);
          acItems.push(item);
        });
        dropdown.classList.add('open');
      }

      function selectStation(m) {
        origin.groupId = m.gid;
        origin.name = m.name;
        input.value = m.name;
        input.classList.add('has-value');
        dropdown.classList.remove('open');
        updateSearchButtonState();
      }

      input.addEventListener('input', function () {
        origin.groupId = null; origin.name = '';
        input.classList.remove('has-value');
        updateSearchButtonState();
        showAC(input.value.trim());
      });
      input.addEventListener('focus', function () {
        if (input.value.trim()) showAC(input.value.trim());
      });
      input.addEventListener('blur', function () {
        setTimeout(function () { dropdown.classList.remove('open'); }, 150);
      });
      input.addEventListener('keydown', function (e) {
        if (e.isComposing || e.keyCode === 229) return;
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (acItems.length > 0) { activeIdx = (activeIdx + 1) % acItems.length; updateActiveAC(); }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (acItems.length > 0) { activeIdx = (activeIdx - 1 + acItems.length) % acItems.length; updateActiveAC(); }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (dropdown.classList.contains('open') && activeIdx >= 0) {
            var matches = searchStations(input.value.trim());
            if (matches[activeIdx]) selectStation(matches[activeIdx]);
          } else if (dropdown.classList.contains('open')) {
            var matches2 = searchStations(input.value.trim());
            if (matches2.length === 1) selectStation(matches2[0]);
          } else if (origin.groupId) {
            runSearch();
          }
        } else if (e.key === 'Escape') { dropdown.classList.remove('open'); }
      });

      function updateActiveAC() {
        acItems.forEach(function (el, i) { el.classList.toggle('active', i === activeIdx); });
        if (activeIdx >= 0 && acItems[activeIdx]) acItems[activeIdx].scrollIntoView({ block: 'nearest' });
      }

      inputWrap.appendChild(input);
      inputWrap.appendChild(dropdown);
      tdStation.appendChild(inputWrap);
      row.appendChild(tdStation);

      // Transfers cell
      var tdTransfers = document.createElement('td');
      var tInput = document.createElement('input'); tInput.type = 'number'; tInput.min = '0'; tInput.max = '10';
      tInput.className = 'cond-number';
      tInput.value = origin.maxTransfers !== null ? origin.maxTransfers : '1';
      tInput.addEventListener('input', function () { origin.maxTransfers = parseInt(tInput.value) || 0; });
      tdTransfers.appendChild(tInput);
      row.appendChild(tdTransfers);

      // Minutes cell
      var tdMinutes = document.createElement('td');
      var mInput = document.createElement('input'); mInput.type = 'number'; mInput.min = '1'; mInput.max = '180';
      mInput.className = 'cond-number';
      mInput.value = presetMinutes || '';
      mInput.placeholder = '-';
      mInput.addEventListener('input', function () {
        var v = parseInt(mInput.value);
        origin.maxMinutes = v > 0 ? v : null;
      });
      origin.maxMinutes = presetMinutes || null;
      tdMinutes.appendChild(mInput);
      row.appendChild(tdMinutes);

      // Remove button cell
      var tdRemove = document.createElement('td');
      var removeBtn = document.createElement('button');
      removeBtn.className = 'remove-origin'; removeBtn.textContent = '×'; removeBtn.title = '削除';
      removeBtn.addEventListener('click', function () {
        var i = origins.indexOf(origin);
        if (i >= 0) { origins.splice(i, 1); row.remove(); }
        if (origins.length < 5) btnAdd.style.display = '';
        updateRemoveButtons();
        updateSearchButtonState();
      });
      tdRemove.appendChild(removeBtn);
      row.appendChild(tdRemove);

      originsEl.appendChild(row);
      origins.push(origin);
      if (origins.length >= 5) btnAdd.style.display = 'none';
      updateRemoveButtons();
      updateSearchButtonState();
      if (!presetGroupId) input.focus();
    }

    function updateRemoveButtons() {
      var btns = originsEl.querySelectorAll('.remove-origin');
      for (var i = 0; i < btns.length; i++) {
        btns[i].style.visibility = origins.length <= 1 ? 'hidden' : 'visible';
      }
    }

    function updateSearchButtonState() {
      var hasValid = origins.some(function (o) { return o.groupId; });
      btnSearch.disabled = !hasValid;
    }

    btnAdd.addEventListener('click', function () { addOriginRow(); });

    /* ========== Search ========== */
    btnSearch.addEventListener('click', function () { runSearch(); });

    function executeSearch(options) {
      var showLoading = options.showLoading !== false;
      var resetPaging = options.resetPaging !== false;
      var doSaveHash = options.saveHash !== false;
      var callback = options.callback || null;

      var validOrigins = origins.filter(function (o) { return o.groupId; });
      if (validOrigins.length === 0) {
        if (showLoading) resultsArea.innerHTML = '<div class="no-results">出発地を選択してください</div>';
        return;
      }

      var hasNoConstraint = validOrigins.some(function (o) {
        return o.maxTransfers === null && o.maxMinutes === null;
      });
      if (hasNoConstraint) {
        if (showLoading) resultsArea.innerHTML = '<div class="no-results">乗換回数または所要時間の条件を1つ以上設定してください</div>';
        return;
      }

      if (showLoading) {
        resultsArea.innerHTML = '<div class="loading"><div class="loading-spinner"></div>検索中…</div>';
      }

      setTimeout(function () {
        var allResults = [];
        validOrigins.forEach(function (o) {
          allResults.push({ origin: o, reachable: searchReachable(o.groupId, o.maxTransfers, o.maxMinutes) });
        });

        if (allResults.length === 0) { renderResults([]); return; }

        var commonGids;
        if (allResults.length === 1) {
          commonGids = Object.keys(allResults[0].reachable);
        } else {
          commonGids = Object.keys(allResults[0].reachable);
          for (var r = 1; r < allResults.length; r++) {
            var rr = allResults[r].reachable;
            commonGids = commonGids.filter(function (gid) { return rr[gid] !== undefined; });
          }
        }

        var entries = [];
        commonGids.forEach(function (gid) {
          var g = groupInfo[gid];
          if (!g) return;
          var access = [];
          allResults.forEach(function (ar) {
            var info = ar.reachable[gid];
            access.push({ originName: ar.origin.name, originGroupId: ar.origin.groupId, transfers: info.transfers, minutes: info.minutes, maxTransfers: ar.origin.maxTransfers, maxMinutes: ar.origin.maxMinutes });
          });
          entries.push({
            gid: gid, info: g, access: access,
            totalTransfers: access.reduce(function (s, a) { return s + a.transfers; }, 0),
            totalMinutes: access.reduce(function (s, a) { return s + a.minutes; }, 0),
            maxTransfers: Math.max.apply(null, access.map(function (a) { return a.transfers; })),
            maxMinutes: Math.max.apply(null, access.map(function (a) { return a.minutes; })),
            minMinutes: Math.min.apply(null, access.map(function (a) { return a.minutes; }))
          });
        });

        var originGids = {};
        validOrigins.forEach(function (o) { originGids[o.groupId] = true; });
        entries = entries.filter(function (e) { return !originGids[e.gid]; });

        results = entries;
        if (resetPaging) {
          currentPage = 0;
          currentPrefFilter = '';
        }
        renderResults(entries);
        if (doSaveHash) saveToHash();
        if (callback) callback();
      }, 30);
    }

    function runSearch() {
      executeSearch({ showLoading: true, resetPaging: true, saveHash: true });
    }

    /* ========== Render Results ========== */
    function renderResults(entries) {
      if (!entries || entries.length === 0) {
        resultsArea.innerHTML = '<div class="no-results">条件を満たす駅が見つかりませんでした</div>';
        return;
      }

      var prefs = {};
      entries.forEach(function (e) {
        var pName = RD.prefNames[e.info.pref] || '';
        if (pName) prefs[e.info.pref] = pName;
      });

      var filtered = entries;
      if (currentPrefFilter) {
        filtered = entries.filter(function (e) { return e.info.pref == currentPrefFilter; });
      }

      var countText = currentPrefFilter
        ? filtered.length + ' / ' + entries.length + ' 駅'
        : entries.length + ' 駅が見つかりました';

      var html = '<div class="card"><div class="result-header">';
      html += '<span class="result-count">' + countText + '</span>';
      html += '<div class="result-controls">';
      html += '<select id="sort-select" aria-label="並び替え">';
      html += '<option value="name"' + (currentSort === 'name' ? ' selected' : '') + '>名前順</option>';
      html += '<option value="transfers"' + (currentSort === 'transfers' ? ' selected' : '') + '>乗換回数順</option>';
      html += '<option value="minMinutes"' + (currentSort === 'minMinutes' ? ' selected' : '') + '>所要時間順</option>';
      html += '<option value="avgMinutes"' + (currentSort === 'avgMinutes' ? ' selected' : '') + '>平均所要時間順</option>';
      html += '</select>';
      html += '<button class="sort-dir-btn" id="sort-dir-btn">' + (currentSortDir === 'asc' ? '↑昇順' : '↓降順') + '</button>';

      var validOrigins = origins.filter(function (o) { return o.groupId; });
      if ((currentSort === 'transfers' || currentSort === 'minMinutes') && validOrigins.length >= 2) {
        html += '<select id="sort-origin-select" aria-label="基準駅">';
        html += '<option value=""' + (currentSortOrigin === '' ? ' selected' : '') + '>全駅</option>';
        validOrigins.forEach(function (o) {
          html += '<option value="' + o.name + '"' + (currentSortOrigin === o.name ? ' selected' : '') + '>' + escapeHtml(o.name) + '</option>';
        });
        html += '</select>';
      }

      var prefKeys = Object.keys(prefs).sort(function (a, b) { return +a - +b; });
      if (prefKeys.length > 1) {
        html += '<select id="pref-filter" aria-label="都道府県フィルタ">';
        html += '<option value="">全都道府県</option>';
        prefKeys.forEach(function (pk) {
          html += '<option value="' + pk + '"' + (currentPrefFilter == pk ? ' selected' : '') + '>' + escapeHtml(prefs[pk]) + '</option>';
        });
        html += '</select>';
      }
      html += '<div class="view-toggle" id="view-toggle">';
      html += '<button data-view="list"' + (!resultsMapView ? ' class="active"' : '') + '>一覧</button>';
      html += '<button data-view="map"' + (resultsMapView ? ' class="active"' : '') + '>地図</button>';
      html += '</div>';
      html += '<button class="btn-share" id="btn-share">共有</button>';
      html += '</div></div>';

      filtered = sortEntries(filtered, currentSort, currentSortDir, currentSortOrigin);

      if (resultsMapView) {
        html += '<div id="results-map-container"></div>';
      } else {
        var totalPages = Math.ceil(filtered.length / PAGE_SIZE);
        if (currentPage >= totalPages) currentPage = totalPages - 1;
        if (currentPage < 0) currentPage = 0;
        var start = currentPage * PAGE_SIZE;
        var pageItems = filtered.slice(start, start + PAGE_SIZE);

        html += '<ul class="station-list">';
        pageItems.forEach(function (e) { html += renderStationItem(e); });
        html += '</ul>';

        if (totalPages > 1) {
          html += '<div class="paging">';
          html += '<button data-page="prev"' + (currentPage === 0 ? ' disabled' : '') + '>&lt;</button>';
          for (var p = 0; p < totalPages; p++) {
            if (totalPages > 7 && Math.abs(p - currentPage) > 2 && p !== 0 && p !== totalPages - 1) {
              if (p === 1 || p === totalPages - 2) html += '<button disabled>…</button>';
              continue;
            }
            html += '<button data-page="' + p + '"' + (p === currentPage ? ' class="active"' : '') + '>' + (p + 1) + '</button>';
          }
          html += '<button data-page="next"' + (currentPage === totalPages - 1 ? ' disabled' : '') + '>&gt;</button>';
          html += '</div>';
        }
      }

      html += '</div>';
      cleanupResultsMap();
      resultsArea.innerHTML = html;

      // View toggle
      var viewToggle = document.getElementById('view-toggle');
      if (viewToggle) {
        viewToggle.querySelectorAll('button').forEach(function (btn) {
          btn.addEventListener('click', function () {
            resultsMapView = btn.getAttribute('data-view') === 'map';
            renderResults(results);
          });
        });
      }

      // Event listeners
      var sortSel = document.getElementById('sort-select');
      if (sortSel) sortSel.addEventListener('change', function () { currentSort = sortSel.value; currentPage = 0; renderResults(results); });

      var sortDirBtn = document.getElementById('sort-dir-btn');
      if (sortDirBtn) sortDirBtn.addEventListener('click', function () {
        currentSortDir = currentSortDir === 'asc' ? 'desc' : 'asc';
        currentPage = 0;
        renderResults(results);
      });

      var sortOriginSel = document.getElementById('sort-origin-select');
      if (sortOriginSel) sortOriginSel.addEventListener('change', function () {
        currentSortOrigin = sortOriginSel.value;
        currentPage = 0;
        renderResults(results);
      });

      var prefFil = document.getElementById('pref-filter');
      if (prefFil) prefFil.addEventListener('change', function () { currentPrefFilter = prefFil.value; currentPage = 0; renderResults(results); });

      var shareBtn = document.getElementById('btn-share');
      if (shareBtn) shareBtn.addEventListener('click', function () {
        if (navigator.clipboard) {
          navigator.clipboard.writeText(location.href).then(function () { if (window.__TT_showToast) window.__TT_showToast('URLをコピーしました'); });
        }
      });

      if (resultsMapView) {
        setTimeout(function () { initResultsMap(filtered); }, 50);
      } else {
        // Paging
        resultsArea.querySelectorAll('.paging button').forEach(function (btn) {
          btn.addEventListener('click', function () {
            var p = btn.getAttribute('data-page');
            if (p === 'prev') currentPage--;
            else if (p === 'next') currentPage++;
            else currentPage = parseInt(p);
            renderResults(results);
            resultsArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
          });
        });

        // Station click -> detail view
        resultsArea.querySelectorAll('.station-item').forEach(function (el) {
          el.addEventListener('click', function () {
            var gid = el.getAttribute('data-gid');
            if (gid) {
              showDetailView(gid);
              saveToHash();
              window.scrollTo(0, 0);
            }
          });
        });
      }
    }

    function initResultsMap(filteredEntries) {
      cleanupResultsMap();
      var mapEl = document.getElementById('results-map-container');
      if (!mapEl) return;

      resultsLeafletMap = L.map(mapEl, { zoomControl: true });
      L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }).addTo(resultsLeafletMap);

      var allBounds = [];

      // Origin markers (red)
      var validOrigins = origins.filter(function (o) { return o.groupId; });
      validOrigins.forEach(function (o) {
        var g = groupInfo[o.groupId];
        if (!g) return;
        var sids = g.sids;
        for (var i = 0; i < sids.length; i++) {
          var st = stationMap[sids[i]];
          if (st && st.lat && st.lon) {
            L.circleMarker([st.lat, st.lon], {
              radius: 8, color: '#e55', fillColor: '#e55', fillOpacity: 1, weight: 2
            }).bindTooltip(o.name + '（出発）', { permanent: false }).addTo(resultsLeafletMap);
            allBounds.push([st.lat, st.lon]);
            break;
          }
        }
      });

      // Result markers (blue)
      filteredEntries.forEach(function (e) {
        var sids = e.info.sids;
        for (var i = 0; i < sids.length; i++) {
          var st = stationMap[sids[i]];
          if (st && st.lat && st.lon) {
            var marker = L.circleMarker([st.lat, st.lon], {
              radius: 5, color: '#4a90d9', fillColor: '#4a90d9', fillOpacity: 0.8, weight: 1
            });
            marker.bindTooltip(e.info.name);
            (function (gid) {
              marker.on('click', function () {
                showDetailView(gid);
                saveToHash();
                window.scrollTo(0, 0);
              });
            })(e.gid);
            marker.addTo(resultsLeafletMap);
            allBounds.push([st.lat, st.lon]);
            break;
          }
        }
      });

      if (allBounds.length > 0) {
        resultsLeafletMap.fitBounds(allBounds, { padding: [30, 30] });
      } else {
        resultsLeafletMap.setView([36.5, 138], 6);
      }
    }

    function sortEntries(arr, sortKey, sortDir, sortOrigin) {
      return arr.slice().sort(function (a, b) {
        var cmp = 0;
        if (sortOrigin && (sortKey === 'transfers' || sortKey === 'minMinutes')) {
          var aVal = null, bVal = null;
          a.access.forEach(function (ac) { if (ac.originName === sortOrigin) aVal = ac; });
          b.access.forEach(function (ac) { if (ac.originName === sortOrigin) bVal = ac; });
          if (sortKey === 'transfers') {
            var at = aVal ? aVal.transfers : 9999;
            var bt = bVal ? bVal.transfers : 9999;
            cmp = at - bt;
          } else {
            var am = aVal ? aVal.minutes : 9999;
            var bm = bVal ? bVal.minutes : 9999;
            cmp = am - bm;
          }
        } else {
          if (sortKey === 'transfers') cmp = a.maxTransfers - b.maxTransfers || a.totalMinutes - b.totalMinutes;
          else if (sortKey === 'minMinutes') cmp = a.minMinutes - b.minMinutes || a.totalMinutes - b.totalMinutes;
          else if (sortKey === 'avgMinutes') cmp = a.totalMinutes - b.totalMinutes || a.minMinutes - b.minMinutes;
          else cmp = a.info.name.localeCompare(b.info.name, 'ja');
        }
        return sortDir === 'desc' ? -cmp : cmp;
      });
    }

    function renderStationItem(e) {
      var html = '<li class="station-item" data-gid="' + e.gid + '">';
      html += '<div class="station-top">';
      html += '<span class="station-name">' + escapeHtml(e.info.name) + '</span>';
      html += '<span class="station-pref">' + escapeHtml(RD.prefNames[e.info.pref] || '') + '</span>';
      html += '</div>';

      html += '<div class="line-badges">';
      e.info.lines.forEach(function (l) {
        var bg = '#' + ensureVisibleColor(l.color);
        var textColor = isLightColor(l.color) ? '#333' : '#fff';
        html += '<span class="line-badge" style="background:' + bg + ';color:' + textColor + '">' + escapeHtml(l.name) + '</span>';
      });
      html += '</div>';

      html += '<div class="access-info">';
      e.access.forEach(function (a) {
        html += '<div class="access-line">';
        html += '<span class="access-origin">' + escapeHtml(a.originName) + 'から:</span>';
        html += '<span class="access-detail">乗換' + a.transfers + '回 / 約' + formatMinutes(a.minutes) + '</span>';
        html += '</div>';
      });
      html += '</div>';
      html += '</li>';
      return html;
    }

    /* ========== Detail View ========== */
    function renderDetailView(targetGid) {
      var g = groupInfo[targetGid];
      if (!g) { showSearchView(); return; }

      var validOrigins = origins.filter(function (o) { return o.groupId; });
      if (validOrigins.length === 0) { showSearchView(); return; }

      // Build routes
      var routes = [];
      validOrigins.forEach(function (o) {
        var path = findPath(o.groupId, targetGid, o.maxTransfers, o.maxMinutes);
        routes.push({ originName: o.name, path: path });
      });

      var html = '';

      // Station header card
      html += '<div class="card">';
      html += '<div class="detail-header">';
      html += '<span class="detail-station-name">' + escapeHtml(g.name) + '</span>';
      html += '<span class="detail-pref">' + escapeHtml(RD.prefNames[g.pref] || '') + '</span>';
      html += '</div>';
      html += '<div class="line-badges">';
      g.lines.forEach(function (l) {
        var bg = '#' + ensureVisibleColor(l.color);
        var textColor = isLightColor(l.color) ? '#333' : '#fff';
        html += '<span class="line-badge" style="background:' + bg + ';color:' + textColor + '">' + escapeHtml(l.name) + '</span>';
      });
      html += '</div>';
      html += '</div>';

      // Map container
      html += '<div id="map-container"></div>';

      // Route details
      html += '<div class="route-section">';
      html += '<div class="card-title route-section-title">ルート詳細</div>';

      var ROUTE_COLORS = ['#e55', '#47a', '#3a3', '#d80', '#a5d'];

      routes.forEach(function (route, ri) {
        html += '<div class="route-card">';
        html += '<div class="route-card-header">';
        html += '<span>' + escapeHtml(route.originName) + 'から</span>';
        if (route.path) {
          html += '<span class="route-summary">乗換' + route.path.totalTransfers + '回 / 約' + formatMinutes(route.path.totalMinutes) + '</span>';
        } else {
          html += '<span class="route-summary">経路なし</span>';
        }
        html += '</div>';

        if (route.path && route.path.segments.length > 0) {
          html += '<div class="route-timeline">';
          route.path.segments.forEach(function (seg, si) {
            if (si > 0) {
              html += '<div class="segment-transfer">乗換</div>';
            }
            var color = '#' + ensureVisibleColor(seg.lineColor);
            html += '<div class="route-segment">';
            html += '<div class="segment-line-bar" style="background:' + color + '"></div>';
            html += '<div class="segment-content">';
            html += '<div class="segment-line-name" style="color:' + color + '">' + escapeHtml(seg.lineName) + '</div>';
            var first = seg.stations[0];
            var last = seg.stations[seg.stations.length - 1];
            html += '<div class="segment-stations">' + escapeHtml(first.name) + ' → ' + escapeHtml(last.name) + '（' + seg.stations.length + '駅）</div>';
            html += '</div></div>';
          });
          html += '</div>';
        }
        html += '</div>';
      });

      html += '</div>';
      detailContent.innerHTML = html;

      // Init Leaflet map
      setTimeout(function () { initMap(routes, ROUTE_COLORS); }, 50);
    }

    function initMap(routes, routeColors) {
      if (leafletMap) { leafletMap.remove(); leafletMap = null; }

      var mapEl = document.getElementById('map-container');
      if (!mapEl) return;

      leafletMap = L.map(mapEl, { zoomControl: true });
      L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }).addTo(leafletMap);

      var allBounds = [];

      routes.forEach(function (route, ri) {
        if (!route.path || route.path.segments.length === 0) return;
        var routeColor = routeColors[ri % routeColors.length];

        route.path.segments.forEach(function (seg) {
          var latlngs = [];
          seg.stations.forEach(function (st) {
            if (st.lat && st.lon) {
              latlngs.push([st.lat, st.lon]);
              allBounds.push([st.lat, st.lon]);
            }
          });
          if (latlngs.length > 1) {
            L.polyline(latlngs, {
              color: '#' + ensureVisibleColor(seg.lineColor),
              weight: 4,
              opacity: 0.85
            }).addTo(leafletMap);
          }
        });

        // Markers for origin and target
        var firstSeg = route.path.segments[0];
        var lastSeg = route.path.segments[route.path.segments.length - 1];
        if (firstSeg && firstSeg.stations.length > 0) {
          var origin = firstSeg.stations[0];
          if (origin.lat && origin.lon) {
            L.circleMarker([origin.lat, origin.lon], {
              radius: 7, color: routeColor, fillColor: routeColor,
              fillOpacity: 1, weight: 2
            }).bindTooltip(route.originName, { permanent: false }).addTo(leafletMap);
          }
        }
        if (lastSeg && lastSeg.stations.length > 0) {
          var dest = lastSeg.stations[lastSeg.stations.length - 1];
          if (dest.lat && dest.lon) {
            L.circleMarker([dest.lat, dest.lon], {
              radius: 8, color: '#333', fillColor: '#fff',
              fillOpacity: 1, weight: 3
            }).bindTooltip(dest.name, { permanent: false }).addTo(leafletMap);
          }
        }
      });

      if (allBounds.length > 0) {
        leafletMap.fitBounds(allBounds, { padding: [30, 30] });
      } else {
        leafletMap.setView([36.5, 138], 6);
      }
    }

    /* ========== Helpers ========== */
    function formatMinutes(m) {
      if (m === 0) return '0分';
      var total = Math.round(m);
      var h = Math.floor(total / 60);
      var min = total % 60;
      if (h > 0) return h + '時間' + (min > 0 ? min + '分' : '');
      return min + '分';
    }

    function isLightColor(hex) {
      var r = parseInt(hex.substr(0, 2), 16);
      var g = parseInt(hex.substr(2, 2), 16);
      var b = parseInt(hex.substr(4, 2), 16);
      return (r * 299 + g * 587 + b * 114) / 1000 > 160;
    }

    function ensureVisibleColor(hex) {
      var r = parseInt(hex.substr(0, 2), 16);
      var g = parseInt(hex.substr(2, 2), 16);
      var b = parseInt(hex.substr(4, 2), 16);
      var maxC = Math.max(r, g, b);
      var minC = Math.min(r, g, b);
      if (maxC - minC <= 30 && minC >= 50 && maxC <= 200) {
        return 'E8529A';
      }
      return hex;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    /* ========== URL Hash ========== */
    function saveToHash() {
      var parts = [];
      origins.forEach(function (o) {
        if (!o.groupId) return;
        var p = 'o=' + encodeURIComponent(o.name) + ',g' + o.groupId;
        if (o.maxTransfers !== null) p += ',t' + o.maxTransfers;
        if (o.maxMinutes !== null) p += ',m' + o.maxMinutes;
        parts.push(p);
      });
      var hash = parts.join('|');
      if (currentDetailGid) {
        hash += '&d=' + currentDetailGid;
      }
      if (hash) {
        history.pushState(null, '', '#' + hash);
      }
    }

    function loadFromHash() {
      var hash = location.hash.substring(1);
      if (!hash) return false;

      // Parse detail gid
      var detailGid = null;
      var mainPart = hash;
      var ampIdx = hash.indexOf('&d=');
      if (ampIdx !== -1) {
        detailGid = hash.substring(ampIdx + 3);
        mainPart = hash.substring(0, ampIdx);
      }

      var parts = mainPart.split('|');
      var loaded = [];
      parts.forEach(function (part) {
        if (!part) return;
        var params = {};
        part.split(',').forEach(function (kv) {
          if (kv.indexOf('o=') === 0) params.name = decodeURIComponent(kv.substring(2));
          else if (kv.charAt(0) === 'g') params.groupId = kv.substring(1);
          else if (kv.charAt(0) === 't') params.transfers = parseInt(kv.substring(1));
          else if (kv.charAt(0) === 'm') params.minutes = parseInt(kv.substring(1));
        });
        if (params.name) {
          var match = null;
          if (params.groupId && groupInfo[params.groupId]) {
            match = { gid: params.groupId, name: groupInfo[params.groupId].name };
          } else {
            match = searchIndex.find(function (s) { return s.name === params.name; });
          }
          if (match) {
            loaded.push({
              gid: match.gid, name: match.name,
              transfers: params.transfers !== undefined ? params.transfers : 1,
              minutes: params.minutes !== undefined ? params.minutes : undefined
            });
          }
        }
      });

      if (loaded.length > 0) {
        loaded.forEach(function (l) { addOriginRow(l.gid, l.name, l.transfers, l.minutes); });
        if (detailGid) {
          currentDetailGid = detailGid;
          setTimeout(function () {
            runSearchThen(function () {
              showDetailView(detailGid);
            });
          }, 100);
        }
        return true;
      }
      return false;
    }

    function runSearchThen(callback) {
      executeSearch({ showLoading: false, resetPaging: false, saveHash: false, callback: callback });
    }

    // Handle browser back/forward
    window.addEventListener('popstate', function () {
      var hash = location.hash.substring(1);
      var ampIdx = hash.indexOf('&d=');
      if (ampIdx !== -1) {
        var detailGid = hash.substring(ampIdx + 3);
        if (detailGid && groupInfo[detailGid]) {
          showDetailView(detailGid);
          return;
        }
      }
      if (currentDetailGid) {
        showSearchView();
      }
    });

    /* ========== Init ========== */
    if (!loadFromHash()) {
      addOriginRow();
    } else if (!currentDetailGid) {
      setTimeout(runSearch, 100);
    }

  })();
  </script>
</body>
</html>
